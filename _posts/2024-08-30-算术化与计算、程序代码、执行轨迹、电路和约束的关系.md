#zkp

## 算术化与计算、程序代码、执行轨迹、电路和约束的关系

算术化的核心目标是将计算（computation）等价映射为数学的多项式约束（polynomial constraints）。在学习算术化时，我们常常会遇到一些相关的概念，包括计算（computation）、程序代码（program code）、执行轨迹（execution trace）、电路（circuits）和约束（constraints）。

我曾感到困惑：**程序代码如何编译成 circuits，尤其是包含循环语句的程序？**

后来我才意识到这个问题的表述本身就是不恰当的。而我之所以会产生这个不恰当的问题描述，是因为我被一些不严谨的表述误导了。许多文章在介绍算术化时，为了清晰地切入主题，通常会先举一些简单的算术例子，如  [Quadratic Arithmetic Programs by Vitalik](https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649) 中的 `x^3 + x + 5` ，或者 [STARK 101](https://starkware.co/stark-101/) 中的斐波那茨数列，来说明如何将该算术等价映射为多项式约束。这让我误以为程序代码是直接静态编译成电路的。

<br />

其实，实际要复杂一些的：

许多 zk 程序是基于固定电路设计的，它们不包含循环控制结构，因此可以将程序代码直接静态编译成电路。

但对于像 zkVM 这样包含循环控制的程序，我们需要先动态执行程序，生成执行轨迹，然后再将这些轨迹转化为电路或其他形式的数学约束。

<br />


总结：

「计算 computation」是一个泛指，对于固定电路的程序而言，它或许指的是程序代码；对于非固定电路的程序，它则指的是执行轨迹。

「编译 compilation」是指将代码静态地转换成另一种形式的过程，对于固定电路的程序而言可以说「program code 编译成 circuit」，但是对于非固定电路的程序则不可以这样说，更好的表述是「执行」。通过这种方式，我们可以更准确地理解和表达算术化过程中的各个环节。
