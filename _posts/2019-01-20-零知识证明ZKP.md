---
layout: post
title: "零知识证明 ZKP"
date: 2019-01-20
---

#zkp 

## References

- Awesome:
	- [[零知识证明学习资源汇总]]
	- https://github.com/Whisker17/zkpThings/blob/dev/Awesome_Resources.md
	- https://github.com/h4m5t/Cryptography
- Courses:
	- https://zk-learning.org/ Zero Knowledge Proofs ⭐️⭐️
	- https://zkiap.com/ 好难好难好难，不过里头有编程的内容
	- [ZK Whiteboard Sessions](https://www.youtube.com/watch?v=h-94UhJLeck&list=PLj80z0cJm8QErn3akRcqvxUsyXWC81OGq&ab_channel=ZeroKnowledge)
	- [Lecture 10.3: What is a zk-SNARK? | Blochain-Web3 MOOCs](https://www.youtube.com/watch?v=gcKCW7CNu_M&ab_channel=Blockchain-Web3MOOCs) 
	- [zku.one](https://www.youtube.com/watch?v=G-7Zgt-ZcMs&ab_channel=HarmonyProtocol)
	- [Dora Dōjō & lynndell博士 | 密码学系列](https://space.bilibili.com/445312136/channel/collectiondetail?sid=988411&spm_id_from=333.788.0.0)
	- https://github.com/Whisker17/zkpThings/blob/dev/Awesome_Resources.md#courses
	- https://www.youtube.com/watch?v=Tg-Z4ESZ8yg 星辰实验室
	- https://www.youtube.com/watch?v=TQjzKAkHFls&ab_channel=DappLearning 星辰实验室
	- https://www.youtube.com/playlist?list=PLgPVMJY4tnFMynvSMXsSLcnBG0MRf-Iir 星辰实验室 三大课程！！！
	- 很多人推荐的斯坦福课程 密码学 https://www.bilibili.com/video/BV1Ht411w7Re/?share_source=copy_web&vd_source=f788a1bd8e82a78a44b9812bae78af9c
	- Doro Hack 密码学合集： https://space.bilibili.com/445312136/channel/collectiondetail?sid=988395
	- 密码学的数学基础，好多密码学中用到的数学概念: https://space.bilibili.com/552018206/channel/collectiondetail?sid=436262
	- 信息安全数学基础——哈尔滨工业大学，有很多数学 https://www.bilibili.com/video/BV1zt411S7r8/?share_source=copy_web&vd_source=f788a1bd8e82a78a44b9812bae78af9c
- Playlist:
	- https://www.youtube.com/playlist?list=PL8nBmR5eGh36_5hqeUntwfes-RIRBS9bm
	- https://www.youtube.com/playlist?list=PLbU_qfxXpyN_T3lkWGfZGOMWZC2rnYdFt
- Books:
	- https://github.com/Whisker17/zkpThings/blob/dev/Awesome_Resources.md#books
	- [[图解密码技术 第三版.pdf]]
- People
	- https://www.di.ens.fr/~nitulesc/publications.html 这个女生的主页的 PPT 真是太惊艳了

## 科普

- ⭐️⭐️⭐️ [为何我理解不了零知识证明：ZKP常见误区分析 | 李画 安比实验室](https://mp.weixin.secbit.io/s/mV0Q73OCMlJQA2VjehgWgQ)
- ⭐️⭐️⭐️ - [探索零知识证明系列（一）：](http://mp.weixin.qq.com/s?__biz=MzIxNjkwODE5NQ==&mid=2247483978&idx=1&sn=eb285e8e04c9f706ebb009a82fee8cb8&chksm=9780aa86a0f7239069c939afa67d0484d1f686c5b690523955a17669e5fbe5e7905bfb823eed&scene=21#wechat_redirect)[初识「零知识」与「证明」](http://mp.weixin.qq.com/s?__biz=MzIxNjkwODE5NQ==&mid=2247483978&idx=1&sn=eb285e8e04c9f706ebb009a82fee8cb8&chksm=9780aa86a0f7239069c939afa67d0484d1f686c5b690523955a17669e5fbe5e7905bfb823eed&scene=21#wechat_redirect)
  - [可验证计算与电路可满足性问题](https://secbit.io/blog/2019/07/31/zero-knowledge-and-proof/#%E5%8F%AF%E9%AA%8C%E8%AF%81%E8%AE%A1%E7%AE%97%E4%B8%8E%E7%94%B5%E8%B7%AF%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7%E9%97%AE%E9%A2%98)
  - 证明存在的意义是什么？所有的==证明都体现了「证明」与「验证」的「不对称性」==。证明可能是一个非常耗费算力，或者脑力的活动，无论是耗时几百年的「费马大定理」，还是比特币中的 POW 证明，这些证明都凝结了在寻找证明过程中所消耗的能量，证明过程可能是超乎寻常的复杂，偶尔需要天才横空出世。而验证过程一定（或者应该）是一个非常简单的，机械的，在（多项式）有效时间内且能终止的活动。==某种意义上，这个不对称性真正体现了证明的意义，展示了零知识证明的价值。==
-   [探索零知识证明系列二：从「模拟」理解零知识证明：平行宇宙与时光倒流](https://sec-bit.github.io/blog/2019/08/06/understand-zero-knowledge-proof-by-simulator/)
-   [探索零知识证明系列三：读心术：从零知识证明中提取「知识」](https://sec-bit.github.io/blog/2019/08/28/extractor-and-proof-of-knowledge/)
-   [探索零知识证明系列四：亚瑟王的「随机」挑战：从交互到非交互式零知识证明](https://sec-bit.github.io/blog/2019/11/01/from-interactive-zkp-to-non-interactive-zkp/)

- 看了几篇介绍“什么是零知识证明”的文章之后，我意识到，“零知识证明”跟“区块链”一样，是一个不容易圈定的技术。所以我不用在初期纠结于这个问题，粗略理解即可，先学习后面的阶段，以后再回过头来总结这个问题（毕竟我都还没有总结好“什么是区块链”）。另一个理由是，我更在意工程上的zk，而不是理论上。
- 我的心得：零知识证明跟一般问题不同，在零知识证明中，Verifier 只想知道 “prover **是否** 知道正确的秘密”，而不想知道“秘密是什么”。这个区别非常重要，因为这个区别把问题变成判定性问题，所以才用上了 Schwatz-Zipple lemma。The importance of the Schwartz–Zippel Theorem and Testing Polynomial Identities follows from algorithms which are obtained to problems that can be reduced to the problem of [polynomial identity testing](https://en.wikipedia.org/wiki/Polynomial_identity_testing "Polynomial identity testing").

- [ZK 技术的学习心得和经验分享 | 郭宇](https://learnblockchain.cn/article/5701)
## 学习心得

- 走两步，看两步 ------ 知道自己不知道，这才能更有效地去学习
- zkp "zk" 是手段，"p" 是目标。理解项目的 Proof 非常重要，因为这就是理解要解决什么问题。
- 通过理解和反复推敲一个密码学协议的性质，来深入理解密码学协议：
	- Completeness (honest prover assumed, verifier should accept)
	- Soundness (malicious prover assumed, verifier should reject)
	- Zero-knowledge (malicious verifier assumed, witness should not be computed)
- 推敲的技巧：
	- 某交互顺序是否能调换？
	- 某交互步骤是否能省略？
	- 某秘密泄漏会怎样？

## 哈希函数

- SHA (Secure Hash Algorithm), SHA-256, SHA2-256, SHA3-256
- Keccak-256 是 SHA3-256 的变体，在代码中更改了一些常量。[Keccak-256 经常被错误地称为 SHA256 或者 SHA3](https://github.com/ethereum/eth-hash)
- [BLAKE](https://en.wikipedia.org/wiki/BLAKE_%28hash_function) / BLAKE2 / BLAKE2s(256bits) / BLAKE2b(512bits)
- [RIPEMD-160, RIPE Message Digest](https://en.wikipedia.org/wiki/RIPEMD)


## 密钥配送问题 Key Distribution Problem

Symmetric Encryption 即公钥密码学或者共享密钥密码学，用相同的密钥进行加密和解密。

在 Symmetric Encryption 时代，想要在公开透明的网络里做到秘密通讯，前提是双方知晓同一个共享密钥，且其它人不能知道该共享密钥。共享密钥的传递问题，就是基于这个上下文提出来的，如何传递共享密钥。要点：
1. Symmetric Encryption 时代
2. 公开透明的网络
3. 通信双方共享密钥，但不被第三者知晓

解决方案：
1. 可信第三方。破坏了“公开透明”的假设。
2. 可信通道。破坏了“公开透明”的假设。
3. DH key agreement protocol。双方仅通过交换 一些可以公开的信息 就能够**生成出共享的秘密数字**。本质上 DH exchange 就是一种 Asymmetric Encryption。
4. 直接采用非对称加密通讯 Asymmetric Encryption，就没有配送问题了。

## 密钥协商协议 Diffie-Hellman Key Agreement Protocol

> [!seealso] 
> - [数学不好也能听懂的算法 - DH密钥交换  | B 站视频](https://www.bilibili.com/video/BV1sY4y1p78s/?spm_id_from=333.788)
> - [[零知识证明 ZKP#密码学前置知识：群论]]

群 $(\mathbb{G}, n, g)$，生成元是 $g$，二元运算是乘法 $g_1 * g_2 \mod n$，$g^x$ 表 $g$ 进行自身 $x$ 次运算。

1. Alice 的私钥 $a$，公钥 $A = g^a \mod n$，将公钥 $A$ 发送给 Bob。
2. Bob 的私钥 $b$，公钥 $B = g^b \mod n$，将公钥 $B$ 发送给 Alice。
3. Alice 计算 $s = B^a \mod n$
4. Bob 计算 $s = A^b \mod n$。
因为 $(g^a \mod n)^b \mod n = (g^b \mod n)^a \mod n$，Alice 和 Bob 现在共享同一密钥 $s$ 或者 $hash(s)$，而 $a$ 和 $b$ 仍然保密。

Diffie-Hellman密钥交换利用“离散对数问题”的复杂性来安全地交换密钥。如果我们将问题变为“椭圆曲线上的离散对数问题”，所使用的算法就被称为椭圆曲线Diffie-Hellman密钥交换。椭圆曲线Diffie-Heliman密钥交换在总体流程上是不变的，只是所利用的数学问题不同而已。

**引入随机数增强 Diffie-Hellman 协议**：$s = hash(s, \lambda_1, \lambda_2)$

## ELGamal 加密算法

> [!seealso] 
> - [密码学03｜群和公钥加密](https://www.bilibili.com/video/BV1KG4y1G7ZB/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=3383)

群 $(\mathbb{G}, p, g)$；
生成公私钥对：Alice 选择私钥 $a$，公钥 $A = g^a$；
加密：选择随机数 $r$，加密 $\text{ciphertext} = A^r * \text{plaintext}$，发送 $(g^r, \text{ciphertext})$
解密：$\text{ciphertext} \div (g^r)^a = A^r * \text{plaintext} \div (g^r)^a = (g^a)^r * \text{plaintext} \div (g^r)^a$，得到 $\text{plaintext}$
标准的解密表示：$(g^r)^{-a} * \text{ciphertext} = (g^{-ar}) * (g^{ar} * \text{plaintext}) = \text{plaintext}$

增强版 Elgamal 加密算法：[密码学03｜群和公钥加密](https://www.bilibili.com/video/BV1KG4y1G7ZB/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=3383)

## 映射

我个人总结，一个正确的映射方式 $A \rightarrow B$，$A$ 系统的定义域为 $H_A$，$B$ 系统的定义域为 $H_B$，要满足：
1. 映射元素：$H_A$ 上的所有元素，都能映射到 $H_B$
2. 映射性质：$A$ 系统在 $H$ 定义域上具有某种性质，相应地也要能映射到 $B$ 系统
3. 映射操作：$A$ 系统在 $H$ 定义域上的某些操作（比如加减乘除），相应地也要能映射到 $B$ 系统，具体映射后到操作是怎样？
4. 映射问题：这是我自己的想法，在 [[零知识证明 ZKP#向量 $ rightarrow$ 多项式：[Lagrange Polynomials](https //github.com/sec-bit/learning-zkp/blob/develop/plonk-intro-zh/2-plonk-lagrange-basis.md lagrange-%E6%8F%92%E5%80%BC-%E4%B8%8E-evaluation-form)]] 一例，$\vec{a} \circ \vec{b} - \vec{c} \overset{?}{=} 0$  的原始问题是 “向量 $a$ 乘于向量 $b$ 再减去向量 $c$ 是否恒等于 0”，在映射到多项式并引入了随机性挑战后，$a(\zeta)\cdot b(\zeta)-c(\zeta) - q(\zeta)\cdot z_H(\zeta) \overset{?}{=} 0$ 的问题变为 “随机选一个 $x$，该式子不成立的概率为 ~1（成立的概率为0）”，Verifier 验证的方式是随机选一个 $\zeta$，让 Prover 提供该式子不成立的证明（描述带有统计学的味道:D），如果 Prover 能提供出来证明，那就说明大概率 $a(\zeta)\cdot b(\zeta)-c(\zeta) - q(\zeta)\cdot z_H(\zeta) \overset{?}{=} 0$ 不成立，这就说明，只有在  $\quad\forall X\in H$ 时该式子才成立。

检验映射的方法：将定义域上的元素代入 $B$，看结果是否等价于 $A$ 的情况

很多文章只介绍映射的「步骤」，而没有说明映射前后的「问题」，原来要解决的问题是什么，映射后，对应的要解决的问题是什么？ 就感觉很多人没吧「问题」理清楚，就急着进入「怎么解决问题」了。
理解「问题」对于理解整套系统来说很重要，一定要重视，尤其是 ZK 这种复杂系统，学着学着就忘记为何而学了。比如可以问问自己，“[[零知识证明 ZKP#理解 PLONK（二）：多项式编码]] 把 向量系统 映射到 多项式系统，目的是什么？初始问题是什么？映射后到问题是什么？

ZK 最初想解决的问题是 “在不透露隐私的前提下证明某件事儿”。直接去解决这个问题很难，于是我们期望把它映射成多项式求解问题，后面还引入统计概率工具，将问题映射成概率问题。可能因为直接映射成多项式比较复杂，所以我们中间是先映射成算术电路问题和向量问题。
如果我完全理解这些映射关系，我就应该能把上述这些映射的 How/What/Why 讲清楚，其中 “映射后的问题” 是 What 的重点。

## 群论 / 环 / 域

> [!seealso] 
> - [密码学03｜群和公钥加密_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KG4y1G7ZB/?spm_id_from=333.880.my_history.page.click&vd_source=b7d8f4fe7d99d7045075d9b1f350612b)
> - [密码学04｜Hacker Dōjo 数字签名与KZG承诺_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV17e411N7Jm/?spm_id_from=333.999.0.0&vd_source=b7d8f4fe7d99d7045075d9b1f350612b)

> 群：具有封闭加法运算的集合称为群
> 环：在群的基础上，添加一种运算，如乘法。但每个元素不一定有乘法逆元
> 域：在环的基础上，要求每个元素都有乘法逆元。等于加法群和乘法群

**常见的域**：$Q$ 有理数；$Z$ 整数；$Z^+$ 正整数；$N$ 非负整数；$N^+$ 正整数；$R$ 实数

**群的定义**：只有一个运算的、简单的代数结构（代数结构是指具有一个以及以上运算的非空集合），由 一个集合 $\mathbb{G}$ 和一个二元操作构成，满足以下四个性质： ^1c64a8
1. **封闭性**：如果 $a, b \in \mathbb{G}$，则 $a \cdot b \in \mathbb{G}$
2. **结合律**：$(a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. **单位元 $I$**：存在一个元素使得 $a \cdot I = I \cdot a = a$
4. **逆元**：每个元素 $a$ 都有逆元 $a^{-1}$ 使得 $a \cdot a^{-1} = e$

**阿贝尔群（Abelian Group）**：又称交换群，额外满足一个性质：
5. **交换律**：$a \cdot b = b \cdot a$

**循环群（Cyclic Group）**：循环群都是阿贝尔群，还额外满足一个性质：
6. **生成元**：存在一个元素 $g$，能够通过 **有限次的本身运算** 表达出其它所有元素。一般用 $g^x$ 表达生成元 $g$ 经过 $x$ 次自身运算得到的结果。

群的举例：
- $G = \set{0, 1}$, 除法运算 $\div$。不满足封闭性，比如 $1 \div 0 \notin G$，所以不是群。
- $G = \set{0, 1, 2, 3, 4}$，加法再模5运算 $(x + y) \mod 5$。这是一个满足条件的加法群，单位元为 0，生成元 $\set{1, 2, 3, 4}$。
- $G = \set{0, 1, 2, 3, 4, 5, 6}$，乘法再模7运算 $(x + y) \mod 7$。这是一个满足条件的乘法群，单位元为 0，生成元 $\set{3, 5}$。

**常见的群**：密码学中常见的群是素数群、椭圆曲线群，只是计算的速度不一样。要达到相同的安全性，所需要的私钥位宽不一样。

**环的定义**：由一个集合和两个二元操作构成，满足以下性质：
1. **加法结合律**：$(a + b) + c = a + (b + c)$
2. **加法交换律**：$a + b = b + a$
3. **加法单位元**：$a + I = I + a = a$
4. **加法逆元**：$a + (-a) = I$
5. **乘法结合律**：$(a * b) * c = a * (b * c)$
6. **分配律**：$a * (b + c) = (a * b) + (a * c)$
可以看出，**环** 在加法操作下是个 **阿贝尔群**。

**域的定义**：域，是一个集合，满足加法和乘法的结合律、交换律、分配律、单位元和逆元共五个性质。

**伽罗瓦域**：有限域

## 双线性映射

> [!seealso] 
> - [Hacker Dōjo 密码学04｜数字签名与KZG承诺](https://www.bilibili.com/video/BV17e411N7Jm/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=279)

1. $G_1, G_2, G_T$ 是阶为素数 $p$ 的循环群；
2. $G_1$ 的生成元是 $g_1$，$G_2$ 的生成元是 $g_2$
3. $e$ 为双线性映射函数 $G_1 \times G_2 \rightarrow G_T$，具备以下性质：
	1. 双线性：$e(u^a, v^b) = e(u, v)^{ab} \quad \quad \forall a,b \in \mathbb{Z}^*, u \in G_1, v \in G_2$
	2. 非退化性：$e(g_1, g_2) \neq 1$
	因此，$e(g_1, g_2)$ 是群 $G_T$ 的生成元。（我的推理 $e(u^a, v^b) = e(g^{ax}_1, g^{by}_2) = e(g_1, g_2)^{ax * by}$）


$G_T$ 又称为双线性群。如果 $G_1, G_2$ 是一维的群，那么 $G_T$ 就是二维的群。

## 离散对数

离散对数问题是指在给定的模运算下，解决 $a = g^k \mod n$ 中的 $k$ 值是一个在计算上难以解决的问题，即使你知道了 $a$，$g$ 和 $n$ 的值，要找出 $k$ 也是非常困难的。这就是所说的”离散对数问题”。

## 线性代数

> [!seealso] 
> - [[Introduction_to_Linear_Algebra.pdf]]
> - [MIT 10.06 Linear Algebra](https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/)
> - [线性代数的本质 | 小崔说数 bilibili](https://space.bilibili.com/404686329/channel/collectiondetail?sid=485669)
> 	- [秩的几何意义](https://www.bilibili.com/video/BV1Ve4y1q7u5/?spm_id_from=333.788&vd_source=b7d8f4fe7d99d7045075d9b1f350612b)
> 	- [线性相关，线性无关](https://www.bilibili.com/video/BV1Ah411m7kv)
> - [线性代数的本质 | bilibili](https://www.bilibili.com/video/BV1Ys411k7yQ)
> - [Dear linear algebra students, This is what matrices (and matrix manipulation) really look like](https://www.youtube.com/watch?v=4csuTO7UTMo&ab_channel=ZachStar)
> 		- 尤其是讲到 9:12 的很像 R1CS https://youtu.be/4csuTO7UTMo?t=554


**Heart Concepts**:
- ___vector___, and basic operations: vector addition  $\vec{v} + \vec{w}$ , scala multiplication $c\vec{v}$
- ___linear combination___:  $c\vec{v} + d\vec{w}$
- ___line___, ___plane___, ___space___
- ___dot product___: $\vec{v} \cdot \vec{w}$
- ___matrices___ $A$, ___linear equations___ $Ax = b$, and solutions $x = A^{-1}b$

### Vectors and Linear Combinations

> "You can't add apples and oranges."

vector $v$ as a ___column___: $\vec{v} = \begin{bmatrix} v_1 \\ v_2 \end{bmatrix}$, is also shorten as $\vec{v} = (v1, v2)$ for the row form. Note that $(1, 1)$ is a column vector while $[v_1 \ v_2]$ is a row vector.

vector addition $\vec{v} + \vec{w} = \begin{bmatrix} v_1 + w1 \\ v_2 + w2 \end{bmatrix}$; vector multiplication $2\vec{v} = \begin{bmatrix} 2 * v_1 \\ 2 * v_2 \end{bmatrix}$.

We have three ways to describe v: Two numbers ; Arrow from (0,0) ; Point in the plane.
We add using numbers, and visualize using arrows(head to tail: at the end of $\vec{v}$, place the start of $\vec{w}$)

___linear combination___ of $\vec{v}$ and $\vec{w}$:  $c\vec{v} + d\vec{w}$, is what **Linear Algebra** is built on.

### Dot Product and Length

___dot product___: $(v_1, v_2, v_3) \cdot (w_1, w_2, w_3) = v_1 * w_1 + v_2 * w_2 + v_3 * w_3 = \text{dot product}$; Specially, the dot product is $0$ when $\vec{v}$ and $\vec{w}$ is perpendicular.
___length___ of $\vec{v}$: $|| \vec{v} || = \sqrt{\vec{v} \cdot \vec{v}} = \sqrt{v_1^2 + v_2^2 + v_3^2}$
? dot product 和 length 的几何意义是什么？以及它是为了什么问题而定义的？

### Matrix

We have introduced **linear combination** of **vectors** in the form $c \begin{bmatrix} v_1 \\ v_2 \\ v_3 \end{bmatrix}  + d \begin{bmatrix} u_1 \\ u_2 \\ u_3 \end{bmatrix} + e \begin{bmatrix} w_1 \\ w_2 \\ w_3 \end{bmatrix}$ ,
now we can represent in the matrix form $A\vec{x} = c\vec{v} + d\vec{u} + e\vec{w} = \begin{bmatrix} v_1 & u_1 & w_1 \\ v_2 & u_2 & w_2 \\ v_3 & u_3 & w_3 \end{bmatrix} \begin{bmatrix} c \\ d \\ e \end{bmatrix} = \begin{bmatrix} v_1 * c + u_1 * d + w_1 * e \\ v_2 * c + u_2 * d + w_2 * e \\ v_3 * c + u_3 * d + w_3 * e \end{bmatrix}$,
we say the matrix $A$ acts on $\vec{x}$



### 学习心得

我越来越能感受到，Linear Algebra 是一门语言和一种工具，它能用简洁的矩阵格式去描述、用几何的形式去 visualize、用代数的规则去运算。所以我的学习方式是，直接接纳向量的格式、通过 visualize 去感受、通过代数规则去使用。Linear Algebra 

我还发现，除了「理解」层面，更重要的是「感受」层面。如果说「理解」靠逻辑和联系，那么「感受」就是靠「熟练」，即多思考、多做好题。

这个工具用起来简单、适用范围很广，且能很方便地连通「代数」工具，这是它普及的原因。
，打个比方，找出满足 $c(2, -1) + d(-1, 2) = (1, 0)$ 的 $c$ 和 $d$。
如果使用「几何」的画图方式去找，我感觉很难画出思路和答案。但是如果我们用「代数」的方式把等式化为 $(2c-d, -c+2d) = (1, 0)$，再用高斯消元法算出 $c = 2/3, d = 1/3$

### 附录：[向量积](https://blog.csdn.net/qq_33148001/article/details/104804897)

| 向量积类型                                                               | 符号            | 描述                       |
| :------------------------------------------------------------------ | :------------ | :----------------------- |
| 内积 / Inner Product<br>点乘 / Dot Product<br>数量积 / Scalar Product      | $a \cdot b$   | 两个向量逐元素相乘后求和             |
| 外积 / Exterior Product<br>叉乘 / Cross Product<br>矢量积 / Vector Product | $a \times b$  | 两个向量垂直的向量积，结果是一个向量       |
| 哈达玛积 / Hadamard Product<br>对应元素积 / Elementwise Product              | $a \circ b$   | 两个具有相同shape的矩阵或向量对应元素的乘积 |
| 张量积 / Tensor Product<br>外积 / Outer Product                          | $a \otimes b$ | 两个向量外积，结果是一个矩阵或更高维的张量    |

## 模运算 / 数论

为什么很多加密算法里都用到了取模运算，取模运算有什么特别的性质吗？

1. 封闭性（有限域）:取模运算可以将无限的整数集合转化为有限的整数集合,形成一个有限域。在有限域上进行运算更容易处理和分析,这在密码学中非常重要。

2. 周期性:取模运算具有周期性,即(a + n * m) mod m = a mod m。可以==有效混淆原始数据（？？）==，增加解密的难度。

3. 难以求逆: 已知a和b,求解a * x ≡ b (mod m)是一个难题,特别是当m是一个大素数时。这个性质被用于构建单向函数和公钥密码体系。

4. **乘法逆元存在性**: 在模 ( n ) 的世界里，如果 ( n ) 是质数，则除了 ( 0 ) 之外的每个整数都有乘法逆元。乘法逆元在构建像RSA这样的公钥密码系统中尤其重要，RSA算法依赖于大数的因数分解难题和模运算中乘法逆元的性质。

5. **结合律和分配律**:取模运算满足分配律,(a + b) mod m = ((a mod m) + (b mod m)) mod m。这个性质在密码学中很有用,特别是在同态加密和多方计算中。

6. 欧拉定理:欧拉定理指出,如果a和m互质,那么a^φ(m) ≡ 1 (mod m),其中φ(m)是欧拉函数。这个定理在RSA加密和其他一些公钥密码体系中起着关键作用。

**乘法逆元**：

针对乘法逆元在密码学中的几个具体应用,详细说明它的性质和用法。

1. RSA加密:性质:如果e和φ(n)互质,那么e模φ(n)存在乘法逆元d,满足(e * d) mod φ(n) = 1。用法:在RSA加密中,选择两个大素数p和q,计算n = p * q和φ(n) = (p - 1) * (q - 1)。然后选择一个与φ(n)互质的整数e作为公钥,用扩展欧几里得算法计算e模φ(n)的乘法逆元d作为私钥。加密时计算c ≡ m^e (mod n),解密时计算m ≡ c^d (mod n)。乘法逆元保证了(m^e)^d ≡ m (mod n),即加密和解密的一致性。

2. 模均值算法:性质:如果n和p互质,那么n模p存在乘法逆元n^(-1),满足(n * n^(-1)) mod p = 1。用法:在模均值算法中,参与方将各自的数据m1, m2, …, mn加密后发送给服务方。服务方计算所有数据的和sum,然后计算avg ≡ sum * n^(-1) (mod p),其中n^(-1)是参与方数量n模p的乘法逆元。这个结果就是数据的模均值。乘法逆元的作用是抵消了数据数量n的影响,得到正确的平均值。

3. 有限域运算:性质:在有限域GF(p)中,如果a不等于0,那么a模p存在乘法逆元a^(-1),满足(a * a^(-1)) mod p = 1。用法:在有限域上进行除法运算时,先计算除数的乘法逆元,然后将被除数乘以除数的乘法逆元。例如,计算(b / a) mod p,实际上是计算(b * a^(-1)) mod p,其中a^(-1)是a模p的乘法逆元。这个技巧将除法转化为乘法和取模,避免了在有限域上直接执行除法。

4. 椭圆曲线密码学:性质:如果P是椭圆曲线上的一个点,那么存在一个整数k,使得kP = O,其中O是无穷远点。这个整数k就是P的阶。用法:在椭圆曲线密码学中,点的逆元用于计算减法。如果P是椭圆曲线上的一个点,那么-P就是P的逆元,满足P + (-P) = O。计算-P的方法是,找到一个整数k使得kP = O,然后计算(k-1)P。这个过程实际上是在有限域上计算P的(k-1)倍,而k-1就是k在有限域上的乘法逆元。

5. 密钥交换协议:性质:如果a和p-1互质,那么a模p-1存在乘法逆元a^(-1),满足(a * a^(-1)) mod (p-1) = 1。用法:在Diffie-Hellman密钥交换协议中,双方交换g^a mod p和g^b mod p,然后各自计算(g^b)^a mod p和(g^a)^b mod p,得到相同的共享密钥g^(ab) mod p。如果一方知道另一方的指数,例如Alice知道b,就可以计算b在模p-1意义下的乘法逆元b^(-1),然后计算(g^a)^(b^(-1)) mod p,得到g^(ab^(-1)) mod p,这就是共享密钥g^(ab) mod p的乘法逆元。

综上所述,乘法逆元在密码学中的主要作用是**抵消**或**还原**乘法操作,保证加密和解密的一致性,实现有限域上的除法,以及计算椭圆曲线点的逆元。理解乘法逆元的性质和用法,是设计和分析密码学算法的关键。

## Schwartz-Zippel 引理

> [!seealso] 
> - https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma

我觉得 Schwartz-Zippel 引理是零知识证明的最终工具。建议深刻地研究一下。The importance of the Schwartz–Zippel Theorem and Testing Polynomial Identities follows from algorithms which are obtained to problems that can be reduced to the problem of [polynomial identity testing](https://en.wikipedia.org/wiki/Polynomial_identity_testing "Polynomial identity testing").

代数基本定理告诉我们，$f(z) = a_nz^n + a_{n-1}z^{n-1} + ... + a_1z + a_0 = 0 (a_n \neq 0)$ 在复数域上恰有 $n$ 个根，在实数域上最多有 $n$ 个根。

如果有两个多项式 $f(X)$ 和 $g(X)$ 同为两个次数不超过 $d$ 的多项式。那么 Verifier 只需要给出一个随机挑战值 $\zeta\in \mathbb{F}$，计算 $f(\zeta)$ 是否等于 $g(\zeta)$ 即可大概率得知 $f(X)=g(X)$，其中出错的概率 $\leq\frac{d}{|\mathbb{F}|}$。只要保证 $\mathbb{F}$ 足够大，那么检查出错的概率就可以忽略不计。这个原理被称为 Schwartz-Zippel 定理。


## RSA

> [!seealso] 
> - [数学不好也能听懂的算法 - RSA加密和解密原理和过程  | B 站视频](https://www.bilibili.com/video/BV1XP4y1A7Ui/?spm_id_from=333.788)

困难问题：$a = g^k \mod n$，给出 $a$、$g$、$n$，难以求 $k$。

**RSA生成密钥对**:

| 步骤  | 描述                                                                                      | 数学公式                                |
| --- | --------------------------------------------------------------------------------------- | ----------------------------------- |
| 1   | 选择两个大质数 $p$ 和 $q$，并计算他们的乘积 $n$                                                          | $n = p*q$                           |
| 2   | 计算 $n$ 的欧拉函数 $φ(n)$，这里 $φ(n) = (p-1)*(q-1)$                                             | $φ(n) = (p-1)*(q-1)$                |
| 3   | 选择一个整数 $e$，使得 $1 < e < φ(n)$，且 $e$ 和 $φ(n)$ 互质（即 $e$ 和 $φ(n)$ 的最大公约数为1）。$e$ 被称为公钥指数     | -                                   |
| 4   | 计算 $e$ 关于 $φ(n)$ 的模反元素 $d$，也就是找到一个整数 $d$，使得 $e*d \quad mod \quad φ(n) = 1$， $d$ 被称为私钥指数 | $e*d \equiv 1 \quad mod \quad φ(n)$ |
| 5   | 使用 $(e, n)$ 作为公钥， $(d, n)$ 作为私钥                                                         | -                                   |
**RSA加密解密**:

| 名称         | 表示                 |
| ---------- | ------------------ |
| 私钥         | $(d, n)$           |
| 公钥         | $(e, n)$           |
| RSA加密 $密文$ | $密文 = 明文^e \mod n$ |
| RSA解密 $明文$ | $明文 = 密文^d \mod n$ |

## 椭圆曲线群

> [!seealso] 
> - [数学不好也能听懂的算法 - 椭圆曲线 | B 站视频](https://m.bilibili.com/video/BV1BY411M74G?spm_id_from=333.337.search-card.all.click&vd_source=1accc5c6ff347add0eed4f6accb7b4c4)
> - [Exploring Elliptic Curve Pairings | Vitalik | Medium](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)
> - [[零知识证明 ZKP#群论]]



![[Pasted image 20240517170534.png|600x200]]

椭圆曲线描述方程：$y^2 = x^3 + ax + b$，且满足条件 $4a^3 + 27b^2 ≠ 0$

**运算定义**：
设 $P$ 和 $Q$ 是曲线上某两点，定义运算有：
- **点加** $P \oplus Q$
- **数乘** $kP$，又称标量乘法。$n$ 为整数，则 $kP$ 表示 $P$ 与自身加 $k-1$ 次

**运算规律**：
- 点加运算 满足 交换律 $P + Q = Q + P$
- 点加运算 满足 结合律 $(P + Q) + R = P + (Q + R)$
- 数乘运算 满足 交换律 $mP + nP = nP + mP$
- ==数乘运算 满足 数字部分的结合率 $(mn)P = m(nP)$==
- ==数乘运算 满足 数字部分的分配律 $(m+n)P = mP + nP$==

**实数域上的椭圆曲线群**：
结合 [[零知识证明 ZKP#^1c64a8]] 群和阿贝尔群的定义，我们在椭圆曲线的基础上，可以定义一个 **加法群**，实际上这是一个 **阿贝尔群**：
- 椭圆曲线上的点为群元素
- 单位元为 $0$
- 逆元 $P = (x, y)$，$P^{-1} = (x, -y)$，即对称点

椭圆曲线上的离散对数点困难问题：$Q= kP$，其中 $Q$ 和 $P$ 是椭圆曲线上的点，$k$ 是整数。给出 $Q$ 和 $P$，难以求出 $k$。（[[零知识证明 ZKP#密码学前置知识：计算困难问题]]）

**有限域上的椭圆曲线**（这才是密码学常用的椭圆曲线群，参考 [Star Li 2019关于zk-SNARK的直播](https://www.bilibili.com/video/BV1np4y1H7WJ/?p=2&share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=195)）：
- **有限域** $\mathbb{F}_p$ 的特征数为 $p$，$p$ 为素数。该有限域是由 模 $p$ 的结果组成
- 根据拓展欧几里得定理，对于整数 $a, b$，必存在 $x, y$ 使得 $ax + by = GCD(a, b)$
- **模 $p$ 运算下的乘法逆元**：$a \cdot a^{-1} \equiv 1 (\mod p)$
- 曲线定义：$\{(x,y) \in (\mathbb{F}_p)^2 | y^2 \equiv x^3 + ax + b   (\mod p), 4a^3 + 27b^2 \neq 0 (\mod p)\} \cup \{0\}$

## 椭圆曲线加密算法

**ECC密钥对的生成过程**：

| 步骤  | 描述                             | 数学公式                                        |
| --- | ------------------------------ | ------------------------------------------- |
| 1   | 选择一个有限域$F_p$和一个椭圆曲线方程 $E(a,b)$ | $E(a,b): y^2 = x^3 + ax + b$，有限域 $F_p$      |
| 2   | 在椭圆曲线 $E$ 上选择一个生成元             | $G=(x_1, y_1)$                              |
| 3   | 随机选择一个整数作为私钥                   | 私钥 $d$                                      |
| 4   | 计算点 $Q = d \cdot G$ 作为公钥       | 公钥 $Q=d \cdot G$                            |
| 5   | 输出的密钥对为：私钥 $d$ 和公钥 $Q$         | $(d, Q)$                                    |
|     |                                | 其中，$E(a,b)$ 是公开的共享参数, $G$ 是公开参数<br>包含在公私钥对里 |
**加密步骤**：

| 步骤  | 描述                               | 数学公式            | 补充说明                                         |                   |
| --- | -------------------------------- | --------------- | -------------------------------------------- | ----------------- |
| 1   | 选择一个消息 $M$ 点在椭圆曲线上               | 明文 $M$          | $M$ 表示为点，不同算法采用不同的方式将<br>消息映射到曲线上的点，ECC、SM2等 |                   |
| 2   | 随机选择一个整数 $k$，计算点 $P = kG$        | $P=kG$          | $G$ 为公                                       | $G$ 为公开点，包含在公私钥对里 |
| 3   | 计算点 $Q_m = M + kQ$，$Q_m$ 是加密后的消息 | $Q_m = M + kQ$  |                                              |                   |
| 4   | 输出的密文是点对 $(P, Q_m)$              | 密文 = $(P, Q_m)$ |                                              |                   |
**解密步骤**：

| 步骤  | 描述                                                         | 数学公式           |
| --- | ---------------------------------------------------------- | -------------- |
| 1   | 根据密文点对 $(P, Q_m)$，使用私钥 $d$ 计算 $M = Q_m - dP$，$M$ 是解密后得到的原文 | $M = Q_m - dP$ |
| 2   | 若解密成功，解密出的消息 $M$ 应等于原始的消息                                  | 明文 = $M$       |

**加密原理与 ECDLP**：

椭圆曲线的难度问题被称为椭圆曲线离散对数问题（ECDLP）。给定椭圆曲线 $E$ 上的两个点 $P=kG$，已知 $P$ 和 $G$，求解出整数 $k$ 的问题，即是椭圆曲线离散对数问题。 我看不懂，问 AI 吧。

ECC 的加密强度和椭圆曲线的选择有很大关系，有的椭圆曲线的ECDLP问题相对容易解决，所以选择恰当的椭圆曲线非常关键。

## 逻辑电路和布尔代数

布尔代数（Boolean Algebra）是一种数学结构，由英国数学家乔治·布尔（George Boole）在19世纪中叶提出。

**布尔代数和逻辑电路的关系**：

布尔代数是逻辑电路的理论基础，有了这个理论基础，在实际的电路设计中就更容易地表达逻辑（用数学方法表达电路）和优化电路（运用分配律等数学规律）。总而言之，前者是基础理论，后者是工业技术。基础理论只有三种基础运算（AND、OR、NOT），但在实际的工业技术中，会有更丰富的门（AND、OR、XOR等）。


$逻辑 \rightarrow 一般数学表达式 \rightarrow 布尔表达式 \overset{布尔代数}{\rightarrow} 优化后的布尔表达式  \rightarrow 逻辑电路$

算术电路的运算门是加减乘除，
逻辑电路的运算门是与或非，
所以我觉得逻辑电路也可以称呼为布尔电路。

**布尔代数的基本概念**：

| 概念     | 符号             | 数学公式                                                                                                      | 描述                |
| ------ | -------------- | --------------------------------------------------------------------------------------------------------- | ----------------- |
| 元素值    | $true$/$false$ | -                                                                                                         | 布尔代数中的元素，代表真和假    |
| AND 运算 | $A \land B$    | $A \land B = \text{true if and only if } A \text{ and } B \text{ are true}$                               | 逻辑与，两者都为真时结果为真    |
| OR 运算  | $A \lor B$     | $A \lor B = \text{true if at least one of } A \text{ or } B \text{ is true}$                              | 逻辑或，任一为真时结果为真     |
| NOT 运算 | $\lnot A$      | $\lnot A = \text{true if } A \text{ is false, false if } A \text{ is true}$                               | 逻辑非，取反逻辑值         |
| 交换律    | -              | $A \land B = B \land A$<br>$A \lor B = B \lor A$                                                          | AND 和 OR 运算满足交换律  |
| 结合律    | -              | $(A \land B) \land C = A \land (B \land C)$<br>$(A \lor B) \lor C = A \lor (B \lor C)$                    | AND 和 OR 运算满足结合律  |
| 分配律    | -              | $A \land (B \lor C) = (A \land B) \lor (A \land C)$<br>$A \lor (B \land C) = (A \lor B) \land (A \lor C)$ | AND 和 OR 运算满足分配律  |
| 德摩根定律  | -              | $\lnot (A \land B) = \lnot A \lor \lnot B$<br>$\lnot (A \lor B) = \lnot A \land \lnot B$                  | 描述 NOT 运算与其他运算的关系 |

**逻辑电路的基础元素**：

| 逻辑门              | 输入数量  | 输出条件  | 符号                                            | 数学表达式               |
| ---------------- | ----- | ----- | --------------------------------------------- | ------------------- |
| 非门 (NOT Gate)    | 1     | 输入相反  | $\overline{A}$ 或 $A'$                         | $\lnot A$           |
| 与门 (AND Gate)    | 2个或多个 | 全部为1  | $A \cdot B$ 或 $A \land B$                     | $A \cdot B$         |
| 或门 (OR Gate)     | 2个或多个 | 任一为1  | $A + B$ 或 $A \lor B$                          | $A + B$             |
| 异或门 (XOR Gate)   | 2个或多个 | 奇数个1  | $A \oplus B$                                  | $A \oplus B$        |
| 同或门 (XNOR Gate)  | 2个或多个 | 偶数个1  | $A \odot B$ 或 $\lnot(A \oplus B)$             | $\lnot(A \oplus B)$ |
| 缓冲器 (Buffer)     | 1     | 与输入相同 | $A$                                           | $A$                 |
| 与非门 (NAND Gate)  | 2个或多个 | 非全1   | $\overline{A \cdot B}$ 或 $\lnot(A \land B)$   | $\lnot(A \land B)$  |
| 或非门 (NOR Gate)   | 2个或多个 | 非任1   | $\overline{A + B}$ 或 $\lnot(A \lor B)$        | $\lnot(A \lor B)$   |
| 异或非门 (XNOR Gate) | 2个或多个 | 非奇数个1 | $\overline{A \oplus B}$ 或 $\lnot(A \oplus B)$ | $\lnot(A \oplus B)$ |

**算术电路和逻辑电路的比较**：

|          | 算术电路                                                                                                                                                                                                   | 逻辑电路                                           |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------- |
| 定义       | 一个有向无环图，<br>内部节点表  $+$, $-$, $\times$, $\div$ 等，<br>叶节点标识为输入变量或常数                                                                                                                                      | 一个有向无环图，<br>内部节点表 AND，OR，NOT等,<br>叶节点表示输入变量或常数 |
| 运算性质     | 算术运算                                                                                                                                                                                                   | 逻辑运算                                           |
| 输出结果     | 数值                                                                                                                                                                                                     | 布尔值                                            |
| 输入类型     | 数值                                                                                                                                                                                                     | 布尔值                                            |
| Examples | • $C_{hash}(h,m): (h - SHA256(m))$, <br>  $\|C_{hash}\|\approx 20K$ gates<br><br>• $C_{ECDSAverify}(pk,m,\sigma))$<br>  outputs $0$ if $\sigma$ is a valid ECDSA signature on $m$ with respect to $pk$ |                                                |

## 算术化

通俗而言，算术化（Arithmetization）是将计算转为数学对象的过程。
具体而言，算术化是将计算转为多项式约束的过程。
本质而言，**Computation $\rightarrow$ QAP 的本质是建立计算和多项式约束之间的等价关系**。这使得我们可以将电路计算这一问题转化为多项式约束求解的问题。通过这种转化,我们可以在不泄露电路输入的情况下,证明我们确实进行了一次正确的电路计算，约束条件成立的解等价于电路在给定输入下的运算结果。这就是零知识证明的奥秘所在。

在数学中，我们经常使用 **映射(mapping)** 或者 **同构(isomorphism)** 来描述不同系统之间的等价关系，也就是本文说的 **转化**。通过将问题从一个领域映射到另一个领域，我们可以利用目标领域的数学工具和性质来化简、分析、计算原始问题，做到在保留原始问题本质的同时,利用不同领域的数学工具和性质来解决问题。

完整的等价转化过程参见 [[零知识证明 ZKP#zk-SNARK 协议]]。[[零知识证明 ZKP#zk-SNARK 协议]] 对各个转换的目标做了清晰的提炼：
1. 原计算 转为 Arithmetic Circuit，目的是将复杂的计算拍平成以「门」为单位的电路
2. Arithmetic Circuit 转为 R1CS，目的是转成数学表示，因为线性代数的「矩阵」是一个很亲和的工具，所以选择了阶为1的矩阵。本质上，是使用 rank-1 的「等式条件」来表达「原计算规则」中的「变量的取值范围」。这个阶段把计算规则转为了「约束」，在我看来是一个很神奇的转换，计算问题竟然可以等价地转为约束问题。 参考 [[zk-SNARK协议-星辰实验室.pdf]]
3. R1CS 转为 QAP

各个转换的细节：
1. 原计算 转为 Arithmetic Circuit，操作映射：「运算」简化成二元「乘法门」和二元加法门
2. Arithmetic Circuit 转为 R1CS，操作映射：电路门转为「向量约束」，每行对应一个电路门，每列对应一个变量

各种表示的本质：
1. R1CS 是线性结构的 rank-1 矩阵，每个行向量都是变量的**线性组合**，使用向量点乘，来表达一个「约束」。整个向量组等价于方程组。
2. QAP 是多项式结构，每个多项式都是单一变量的约束，即一个变量对应一个多项式。根据「[[零知识证明 ZKP#密码学前置知识：多项式的值表达 等价于 多项式的系数表达|多项式的值表达等价于多项式的系数表达]]」，我们？？？

| System Mapping                                                    | Constraint Mapping                                                                                                                                                                                                                                                |
| :---------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Computation $\rightarrow$ Arithmetic Circuit**<br><br>树状结构，结构简单 | equation $\rightarrow$ gate                                                                                                                                                                                                                                       |
| **Arithmetic Circuit $\rightarrow$ R1CS**<br><br>线性结构，rank-1 矩阵   | gate $\rightarrow$ rank-1 constraint matrix<br><br>用向量点乘表达约束<br><br>R1CS 的每个约束都是变量的**线性组合**，这种线性约束的形式与QAP中的多项式<br>约束非常契合。<br><br>[向量组等价于方程组](https://www.bilibili.com/video/BV1Ah411m7kv/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=309) |
| **R1CS $\rightarrow$ QAP**<br><br>多项式结构                           | rank-1 constraint matrix $\rightarrow$ polynomial constraint<br><br>用多项式表达约束<br><br>这个转换过程利用了多项式在特定点的取值与约束变量之间的对应关系，<br>从而将电路的计算完整性问题还原为多项式相等性问题。                                                                                                                 |
|                                                                   |                                                                                                                                                                                                                                                                   |

### 约束

> [!note] 约束系统的通俗解释 by Claude-3-opus
> R1CS 是一种约束系统。请通俗地解释一下什么叫约束系统，约束系统的作用是什么？
>> 约束系统是一种数学工具,用来描述和限定未知变量之间的关系。它的作用主要有:
>>
>> 1. 表达问题条件:约束系统可以用等式或不等式等数学语言,清晰地表达问题中各变量需要满足的条件和限制。比如求解方程组,每个方程就是一个等式约束。
>> 2. 缩小解空间:引入约束后,未知变量可能取值的范围会大大缩小。约束越多,解空间就越小,便于我们搜索和定位问题的解。
>> 3. 保证解的合理性:设置恰当的约束,可以避免求解结果不合常理。例如某些变量代表数量,需为非负整数,就要用不等式约束其范围。
>> 4. 提高求解效率:约束虽然看似限制了变量,但恰当的约束能显著减少不必要的搜索,提高算法效率。利用约束进行剪枝和预处理是优化求解性能的重要方法。
>>
>> 所以,约束系统是将复杂问题形式化、结构化的有力工具,能帮助我们理清问题本质,并高效求解。R1CS 是一种用于 zk-SNARK 证明系统的特殊约束系统,它用一种简洁的形式表达了置换证明电路需满足的约束条件。

### [算术电路](https://tlu.tarilabs.com/cryptography/rank-1)

> [!seealso] 
> - [Arithmetic Circuits: a survey of recent results and open questions](https://www.cs.tau.ac.il//~shpilka/publications/SY10.pdf)
> - [算术电路的定义](https://tlu.tarilabs.com/cryptography/rank-1) Definition of Arithmetic Circuit

![[Pasted image 20240521174904.png|Typical Multiplication Gate|200x200]]

> Proof: 我知道一组值，能满足该电路的条件。
> 共识参数：电路
> 秘密知识：$s$
> 

该电路表达 $a_L \cdot a_R - a_O = 0$，
若变量是一维向量，比如 $a_L = (a_{L1}, a_{L2}, ..., a_{Ln})$, $a_R = (a_{R1}, ..., a_{Rn})$, 则 $a_O = (a_{L1} \cdot a_{R1}, a_{L2} \cdot a_{R2}, ..., a_{Ln} \cdot a_{Rn})$，是用 Hadamard product 逐项对应相乘。

<mark style="background: #FF5582A6;">为什么这里的定义使用了 Hadamard product，而不是经典的向量相乘？或者说，这种点乘的定义的本质是什么？</mark>
用什么 product，这跟“电路”想表达的意义有关，因为“电路”表达的是“相乘”，所以对应到向量的 hadamard product 运算，如果电路表达的是别的意思，那么就对应向量的其它操作。这是 system mapping，两个系统的元素和操作要一一映射。

并不是任何一个电路都存在赋值向量。凡是存在合法的赋值向量的电路，被称为可被满足的电路。判断一个电路是否可被满足，是一个 NP-Complete 问题，也是一个 NP 困难问题。

> [!note] 常数乘法门 的优化
> 这里例子中的两个乘法门并不相同，上面的乘法门是左右输入中都含有变量，而下面的乘法门只有一边的输入为变量，另一边为常数。对于后者这类「常数乘法门」，后续我们也把他们看作为特殊的「加法门」，如下图所示，左边电路右下的乘法门等价于右边电路的右下加法门。
> $$x_3 * 2 \rightarrow \begin{array}{|c|c|c|c|c|}
\hline
1 & x_1 & x_2 & x_3 & out \\
\hline
0 & 0 & 0 & 2 & 0 \\
\hline
\end{array}$$
> ![[Pasted image 20240523213340.png]]
> 
> 这只是个优化。其实不把常数乘法门当做特殊的加法门也可以，就规规矩矩地按 
[Vitalik](https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649) 的方式来转成 6 列的 R1CS，是等价的。虽然两种方式的 R1CS 结果长得不一样，但是用方程组的方式化简 R1CS 后得到的结果是一样的，这个我自己确认过了。

### R1CS

> [!seealso] 
> - [Definition of Constraint System](https://tlu.tarilabs.com/cryptography/rank-1)
> - [Rank-1 Constraint System with Application to Bulletproofs | tarilabs](https://tlu.tarilabs.com/cryptography/rank-1)
> - [R1CS | The Zero Knowledge Blog](https://www.zeroknowledgeblog.com/index.php/the-pinocchio-protocol/r1cs)
> - [[零知识证明 ZKP#向量 / 线性代数]]
> - https://www.rareskills.io/post/rank-1-constraint-system

> [!question] 为什么不直接将算术电路转为 QAP，一定要经过 R1CS 吗？
> 我的个人看法是，算术化的本质就是映射。算术电路直接转为QAP在理论上是可行的，但是由于算术电路转线性代数再由线性代数转多项式总体更简单，所以实践中往往采用这样的路径。由此可见，线性代数是一个很好的媒介和数学工具，很多领域都喜欢把问题映射成线性代数来求解，再映射回别的系统。


R1CS 把复杂的约束关系分解成简单的形式，用一种简洁的形式表达一组线性约束条件，便于电路的设计和计算。加法门转化为乘法门，因为乘法门可以方便地转化为多项式约束。

**[Example of Rank-1 Constraint System](https://tlu.tarilabs.com/cryptography/rank-1)**:

One solution to the equation $𝑥_1^2 \dot 𝑥_2 + 𝑥_1 + 1 = 22$, from the preceding example of an arithmetic circuit, is $𝑥_1 = 3$ and $𝑥_2 = 2$ belonging to the appropriate field 𝐹. Thus the solution vector $𝑠 = (𝑐𝑜𝑛𝑠𝑡, 𝑥_1, 𝑥_2, 𝑧, 𝑢, 𝑣, 𝑦)$ becomes $𝑠 =(1,3,2,22,9,18,4)$.

It is easy to check that the R1CS for the computation problem in the preceding example is as follows (one need only test if ⟨𝑎𝐿,𝑠⟩⋅⟨𝑎𝑅,𝑠⟩−⟨𝑎𝑂,𝑠⟩=0​ for each equation).

| Equation                | Rank-1 Constraint System Vectors                                                                    |
| :---------------------- | :-------------------------------------------------------------------------------------------------- |
| $u = x_1 \cdot x_1$     | $a_L = (0, 1, 0, 0, 0, 0, 0), \quad a_R = (0, 1, 0, 0, 0, 0, 0), \quad a_O = (0, 0, 0, 0, 1, 0, 0)$ |
| $v = u \cdot x_2$       | $a_L = (0, 0, 0, 0, 1, 0, 0), \quad a_R = (0, 0, 1, 0, 0, 0, 0), \quad a_O = (0, 0, 0, 0, 0, 1, 0)$ |
| $y = 1 \cdot (x_1 + 1)$ | $a_L = (1, 1, 0, 0, 0, 0, 0), \quad a_R = (1, 0, 0, 0, 0, 0, 0), \quad a_O = (0, 0, 0, 0, 0, 0, 1)$ |
| $z = 1 \cdot (v + y)$   | $a_L = (0, 0, 0, 0, 0, 1, 1), \quad a_R = (1, 0, 0, 0, 0, 0, 0), \quad a_O = (0, 0, 0, 1, 0, 0, 0)$ |
In a more formal definition, an **R1CS** is a set of three matrices $𝐴_𝐿$, $𝐴_𝑅$ and $𝐴_𝑂$, where the rows of each matrix are formed by the corresponding vectors $𝑎_𝐿$, $𝑎_𝑅$ and $𝑎_𝑂$, respectively, as shown in Table 1:
Observe that $(𝐴_𝐿*𝑠^𝑇)⋅(𝐴_𝑅∗𝑠^𝑇)−(𝐴_𝑂∗𝑠^𝑇)=0$, where “∗” is _matrix multiplication_ and $𝑠^𝑇$ is the transpose of the solution vector $𝑠$ 

$(𝐴_𝐿*𝑠^𝑇)⋅(𝐴_𝑅∗𝑠^𝑇)−(𝐴_𝑂∗𝑠^𝑇)=0$ 
$(A_L * s^T)$ 是 dot product，因为这对应的电路是加法门，对应的式子是线性式；
$(...) ⋅ (...)$ 是 hudamard product，因为对应的电路是乘法门，对应的二元乘积，不是线性的；
R1CS 的每一个约束都表示一个乘法门；
因为 $A_L, A_R, A_O$ 都每一项都是线性向量，所以才叫 **Rank-1** constraint system（？ 好像感觉不太对 =_=？）

**思考 R1CS 矩阵说代表的含义**：
- 矩阵等价于一个方程组
- 秩为1的矩阵通常具有这样的结构：矩阵的行或列可以通过彼此的**线性组合**来表示。例如，如果矩阵的秩为1且有两行，那么其中一行可以表示为另一行的标量倍。
- 建议问 AI “一个矩阵的秩为 1，代表了什么含义？”，“请进一步解释 第七点，秩为1的矩阵的矩阵分解”

## [Argument System](https://youtu.be/gcKCW7CNu_M?list=PLS01nW3RtgorEzMOg2dpg7KwB5nhQHhSw&t=417)

https://youtu.be/gcKCW7CNu_M?list=PLS01nW3RtgorEzMOg2dpg7KwB5nhQHhSw&t=1065

**Statement** - 对于QSP/QAP而言，某个计算电路的输入。Statement对证明者和验证者都是公开的。

**Witness** - Witness只有证明者知道。可以理解成，某个计算电路的输出（output）。

| Concept                         | Description                                                                                                                           | Parameters                                                                                                                                                                                     |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Circuit $C$                     | public arithmetic circuit: $C(x, w) \rightarrow F$                                                                                    | $F$ is fix finite field, $F = {0, ..., p-1}$<br><br>$x$ is a public **statement** that we're going to prove<br><br>$w$ is a secret **witness** that the Prover is trying to prove knowledge of |
| Setup $S(C)$                    | $S(C) \rightarrow parameters (S{p}, S{v})$                                                                                            | $S{p}$ for *Prover*<br><br>$S{v}$ for *Verifier*                                                                                                                                               |
| Prover $P$                      | $P(S{p}, x, w) \rightarrow \text{proof   }   \pi$<br><br>*Prover*'s goal: "convince" *Verifier* that $\exists w \ s.t. \ C(x, w) = 0$ | input: $x$, $w$, $S{p}$<br>output: **proof** $\pi$<br><br>$\|\pi\| = O(\log(\|C\|), \lambda)$                                                                                                  |
| Verifier $V$                    | $V(S{v}, x, \pi) \rightarrow \text{accept or reject}$                                                                                 | input: $x$, $\pi$, $S{v}$<br><br>$\text{time}(V) = O(\|x\|, \log(\|C\|), \lambda)$                                                                                                             |
| Non-interactive Argument System | A non-interactive argument system is a triple $(S, P, V)$                                                                             |                                                                                                                                                                                                |

| Requirement of argument system    | Description                                                                                                                                                                                                                                                  |
| :-------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| $\text{Complete}$                 | $\quad \forall x, w: \, C(x, w) = 0 \quad \Rightarrow \quad \Pr \left[ \, V(S_v, x, P(S_p, x, w)) = \text{accept} \, \right] = 1$                                                                                                                            |
| $\text{Argument of knowledge}$    | $\quad V \, \text{accepts} \quad \Rightarrow \quad P \, \text{"knows"} \, w \, \text{s.t.} \, C(x, w) = 0$<br><br>  $P^* \, \text{does not "know"} \, w \quad \Rightarrow \quad \Pr \left[ \, V(S_v, x, \pi) = \text{accept} \, \right] < \text{negligible}$ |
| $\text{Optional: Zero knowledge}$ | $\quad (S_v, x, \pi) \quad \text{"reveals nothing"} \, \text{about} \, w$                                                                                                                                                                                    |

**Setup**: $S(C, r) \rightarrow (S_p, S_v)$, $r$ is random bits

| Types of Setup                         | Description                                                                                                                                        | Example                  |
| :------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ |
| trusted setup per circuit              |                                                                                                                                                    | Groth'16                 |
| truest but universal (updatable) setup | $S = (S_init, S_index)$<br>$S_{init}(\lambda, r) \rightarrow pp$, onetime<br>$S_{index}(pp, C) \rightarrow (S_p, S_v)$, no secret data from prover | Plonk                    |
| transparent setup                      | $S(C)$ does not use secret data (no trusted setup)                                                                                                 | Bulletproof, STARK, DARK |

## 同态计算 Homomorphic

> [!seealso] 
> - [全同态加密技术介绍 | bilibili](https://www.bilibili.com/video/BV18p4y1Z7Ws)
> - [密码学03｜群和公钥加密 | 基于同态加密实现隐私转账](https://www.bilibili.com/video/BV1KG4y1G7ZB/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=2726) 视频的例子挺好的
> - [同态加密与 Paillier/RSA](https://wdxtub.com/flt/flt-03/2020/12/02/)

**解决的问题**：在不提供明文的前提下，委托他人对数据进行计算。A way to delegate processing of your data, without giving away access to it.

我觉得「同态加密」和「承诺」都有 **Hiding** 和 **Binding** 的性质。
「同态加密」作用在「计算」，是将秘密知识等价转为另一种形式，再做运算得到另一种形式的运算结果，最后将运算结果等价转回秘密知识的形式。
「承诺」作用在「压缩数据」，是将数据压缩，只在需要具体的时候才提供 Proof。

| Component                             | Parameter                                                     |
| ------------------------------------- | ------------------------------------------------------------- |
| $KeyGen()  \rightarrow (pk, sk, evk)$ | $pk$ private key<br><br>$sk$ public key<br><br>$evk$ eval key |
| $Enc(pk,m) \rightarrow c$             | $m$ message<br><br>$c$ ciphertext                             |
| $Eval(pk,evk,f,c) \rightarrow cf$     | $cf$ computed ciphertext                                      |
| $Dec(sk,cf) \rightarrow m$            |                                                               |

![[Pasted image 20240519121520.png | 400 x 200]]

| 属性/步骤    | Paillier 同态加密                                                                                                                                                                                     | RSA 同态加密                                                                                                                                                                                                            |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **密钥生成** | 随机选择两个质数 $p$ 和 $q$ 满足 $\|p\|=\|q\|=τ$<br><br>计算 $N = pq$ 和 $\lambda = \text{lcm}(p-1, q-1)$ <br><br>随机选择一个与 $N$ 互质的数 $g$, $1 < g < N$<br><br>随机选择 $r$<br><br>私钥为 $\lambda$, 公钥为 $(N, g)$, 计算钥 $r$ | 随机选择两个质数 $P$ 和 $Q$<br><br>计算 $n = P \times Q$, $\Phi(n) = (P-1)(Q-1)$ <br><br>选取 $e$ 满足 $1 < e < \Phi(n)$ 且 $\gcd(e, \Phi(n)) = 1$ <br>计算 $d$ 使得 $(e \times d) \mod \Phi(n) = 1$ <br><br>私钥为 $(n, d)$, 公钥为 $(n, e)$ |
| **加密**   | $E(m) = g^m r^N \mod N^2 \rightarrow C$<br><br>$m$ message plaintext<br>$C$ ciphertext                                                                                                            | $E(m) = A^e \mod n \rightarrow C$<br><br>$m$ message plaintext<br>$C$ ciphertext                                                                                                                                    |
| **解密**   | $D(C) = C^\lambda \mod N^2 \rightarrow m$                                                                                                                                                         | $D(C) = C^d \mod n \rightarrow m$                                                                                                                                                                                   |
| **加法同态** | $E(m_1) \times E(m_2) = E(m_1 + m_2 \mod N)$                                                                                                                                                      | -                                                                                                                                                                                                                   |
| **乘法同态** | -                                                                                                                                                                                                 | $(m_1^e) \times (m_2^e) = (m_1m_2)^e \mod n$                                                                                                                                                                        |

## 隐私转账

> [!seealso] 
> - [[零知识证明 ZKP#同态计算 Homomorphic]]
> - [密码学03｜群和公钥加密 | 基于同态加密实现隐私转账](https://www.bilibili.com/video/BV1KG4y1G7ZB/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=2726) 视频的例子挺好的

我理解的隐私转账就是基于同态计算。下面举例隐私币（[密码学03｜群和公钥加密](https://www.bilibili.com/video/BV1KG4y1G7ZB/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=2730)）

| 用户    | 公私钥            | 初始余额明文   | 初始余额密文                                                                    |
| :---- | :------------- | :------- | :------------------------------------------------------------------------ |
| Alice | $(a, A = g^a)$ | $m_{a0}$ | $[M_{al}, M_{ar}]$，其中 $M_{al} = g^{r0}, M_{ar} = g^{m_{a0}} \cdot A^{r0}$ |
| Bob   | $(b, B = g^b)$ | $m_{b0}$ | $[M_{br}, M_{br}]$，其中 $M_{bl} = g^{r1}, M_{ar} = g^{m_{b0}} \cdot B^{r1}$ |
| Carol | $(c, C = g^c)$ | 0        |                                                                           |
| Dave  | $(d, D = g^d)$ | 0        |                                                                           |
上述表格为隐私币的初始状态。下面将发生几次转账行为。
第一次转账，Alice 构造交易的过程：
- Alice 给 Carol 转账 $t_1$
- Alice 选择公开随机数 $r_1$ 并基于 Carol 的公钥生成密文  $[T_{1l}, T_{1r}]$，$T_{1l} = g^{r1}$，$T_{1r} = g^{t_1} \cdot C^{r_1}$
- Alice 选择公开随机数 $r'_1$ 并基于 Alice  的公钥生成密文  $[T'_{1l}, T'_{1r}]$，$T'_{1l} = g^{r'_1}$，$T'_{1r} = g^{t'_1} \cdot A^{r'_1}$
- Alice 使用 [[零知识证明 ZKP#ELGamal 加密算法]] 生成证明，证明 $t_1 == t'_1$：
	- $ZK(r_1, r'_1, t_1, t'_1, t_1 == t'_1 | T_{1l}, T_{1r}, T'_{1l}, T'_{1r})$
	- $BulletProof\{0 <= m_{a0} - t_1 <= 2^{32}, 0 <= t_1 <= 2^{32}\}$

交易确认后，
- Carol 的余额状态为 $[T_{1l}, T_{1r}]$。Carol 将其解密得到对应的余额明文 $t_1$:
   $g^{t_1} = T_{1r} \cdot (T_{1l})^{-c}$ = $g^{t_1} \cdot g^{r_1*c} * (g^{r1})^{-c}$
- Alice 的余额状态为 $[M_{al} \cdot T'^{-1}_{1l}, M_{ar} \cdot T'^{-1}_{1r}]$。Alice 将其解密得到对应的余额明文 $m_{a0} - t_1$：
  $g^{t_1} = T'_{1r} \cdot (T'_{1l})^{-c}$

未完不待续...
关于 Sigma 协议的 ZK 证明的构造，证明 $t_1 == t'_1$，也直接视频吧

❓为什么用一个元组来表达状态？一个元素不够吗？

## Pairing

[[Pairing-Based Cryptographic Protocols - A Survey.pdf]]


## Groth16

> [!seealso] 
> - [Groth16 | Star Li | bilibili](https://www.bilibili.com/video/BV1np4y1H7WJ?p=4&vd_source=b7d8f4fe7d99d7045075d9b1f350612b)
## PLONK 0. Intro

> [!seealso] 
> - [How PLONK Works: Part 1 | sCrypt | Medium](https://scryptplatform.medium.com/how-plonk-works-part-1-bc8050f4805e)
> - https://vitalik.eth.limo/general/2019/09/22/plonk.html
> - [PLONK 共学课程](https://github.com/sec-bit/learning-zkp/blob/develop/plonk-intro-zh/1-plonk-arithmetization.md)
> - https://github.com/Fluidex/awesome-plonk
> - PyPlonk
>   - https://github.com/Antalpha-Labs/baby-plonk
>   - https://github.com/0xPARC/plonkathon
>   - https://github.com/ethereum/research/tree/master/py_plonk

> [!note] 
> - naming: high-degree gate == custom gate == polynomial gate

2019-08-21 PLONK 被提出，[Vitalik](https://vitalik.eth.limo/general/2019/09/22/plonk.html) 认为 PLONK 有两项创新，一是 "universal and updateable" trusted setup，二是 Kate polynomial commitment

> [!quote] How PLONK works
>
> Let us start with an explanation of how PLONK works, in a somewhat abstracted format that focuses on polynomial equations without immediately explaining how those equations are verified. A key ingredient in PLONK, as is the case in the [QAPs used in SNARKs](https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649), is a procedure for converting a problem of the form "give me a value 𝑋 such that a specific program 𝑃 that I give you, when evaluated with 𝑋 as an input, gives some specific result 𝑌" into the problem "give me a set of values that satisfies a set of math equations". The program 𝑃 can represent many things; for example the problem could be "give me a solution to this sudoku", which you would encode by setting 𝑃 to be a sudoku verifier plus some initial values encoded and setting 𝑌 to 1 (ie. "yes, this solution is correct"), and a satisfying input 𝑋 would be a valid solution to the sudoku. This is done by representing 𝑃 as a circuit with logic gates for addition and multiplication, and converting it into a system of equations where the variables are the values on all the wires and there is one equation per gate (eg. 𝑥6=𝑥4⋅𝑥7 for multiplication, 𝑥8=𝑥5+𝑥9 for addition).
> 
>> 这段对问题的描述可以仔细学习揣摩一下，主要是揣摩如何描述问题

虽然 ZK 系统可能很强大，不过一般而言，教程介绍一个 ZK 系统是如何工作时，会举一个简单的例子，比如 Here is an example of the problem of finding 𝑥 such that 𝑃(𝑥)=𝑥3+𝑥+5=35 (hint: 𝑥=3)

## PLONK 1. Plonkish

> [!question] 
> 1. common reference string 和 structure reference string 的用途和区别？
> 2. PLONK 的算术化是 computation -> arithmetic circuit -> plonkish -> polynomail?
> 3. 想学习如何在不经过 r1cs 的前提下直接 arithmetic circuit -> polynomial?
> 4. 因为 Plonkish 由两个向量 $\mathsf{Plonkish}_0 \triangleq (Q, \sigma; W)$，所以 Prover 要提供两个证明（一个是置换前的证明，一个是置换后的证明）或者要公开两个常数（$W$ 和 $\sigma$），对吗？
> 5. 思考：为什么置换后就能证明 copy constraint 呢？
> 6. [x] 为什么 Plonkish 必须要引入置换证明，而 R1CS 不需要呢？
>        Plonkish 的 $W$ 矩阵描述约束的是门运算的左右信号，R1CS 的矩阵描述的是变量本身，因此 Plonkish 是缺乏对变量本身对约束的，或者说，Plonkish 的门与门之间没有构建起关联，所以才加入了置换证明，可以理解为置换证明。
> 7. 复制约束是怎么表达的？

> Proof: 我知道一组 $W$，使得满足约束 $Q_Lw_a + Q_Rw_b + Q_Ow_c + Q_Mw_aw_b + Q_C = 0$
> 共识参数：$\sigma$, $Q$
> 秘密知识：$W$

In PLONK, all constraints are normalized/standardized into the following form²:
    $Q_Lw_a + Q_Rw_b + Q_Ow_c + Q_Mw_aw_b + Q_C = 0$
    $w_a$, $w_b$, $w_c$ are left, right, and output wire of a gate;
    all $Q_*$ are constants(Left, Right, Output, Multiply, Constant).

The $Q$ vectors are called **selectors** and encode the circuit structure.
The $w_a$, $w_b$, $w_c$ vectors are called **witness assignments** and represent all wire values derived from user inputs, some of which may be private and only known by the prover.

在 Plonkish 里，矩阵 𝑄 来描述电路（乘法、加法、自定义等），矩阵 $W$ 描述变量。
对于 Prover 和 Verifier 的交换协议， 𝑊 是 Prover 的 witness，属于秘密知识，对 Verifier 保密， 𝑄 矩阵代表了一个实现双方约定共识的电路描述。

表达运算门：R1CS 无需编码表达算术门，因为它只有乘法门；Plonkish 将算术操作提取出来单独表示为 $Q_*$ 矩阵。
表达变量：R1CS 的“列”表示变量，行表示运算；Plonkish 只有三列，行表示运算。
我的直观感受是，Plonkish 将变量和操作拆开，就能支持多种运算门。
依旧是使用线性代数系统来表达，但是 Plonkish 拆得更细，就能组合成更多花样，也更“冗余”。相对而言，R1CS 的功能单一，但更“紧凑”。


$$
Q = \begin{bmatrix} 
Q_{L_1} & Q_{R_1} & Q_{M_1} & Q_{C_1} & Q_{O_1} \\ 
Q_{L_2} & Q_{R_2} & Q_{M_2} & Q_{C_2} & Q_{O_2} \\ 
Q_{L_3} & Q_{R_3} & Q_{M_3} & Q_{C_3} & Q_{O_3} \\ 
Q_{L_4} & Q_{R_4} & Q_{M_4} & Q_{C_4} & Q_{O_4} 
\end{bmatrix},
W = \begin{bmatrix} 
W_{L_1} & W_{R_1} & W_{O_1} \\ 
W_{L_2} & W_{R_2} & W_{O_2} \\ 
W_{L_3} & W_{R_3} & W_{O_3} \\ 
W_{L_4} & W_{R_4} & W_{O_4}
\end{bmatrix}
$$
$$
q_{L}(X) \cdot w_{a}(X) + q_{R}(X) \cdot w_{b}(X) + q_{M}(X)\cdot(w_{a}(X)\cdot w_{b}(X)) + q_{C}(X) -  q_{O}(X)\cdot w_{c}(X) \overset{?}{=} 0
$$
$$
WQ \overset{?}{=} 0 \qquad \text{W is secret knowledge, Q is public}
$$ 



> [!note] R1CS VS Plonkish
> 由于 R1CS 编码以乘法门为中心，于是电路中的加法门并不会增加 𝑈,𝑉,𝑊 矩阵的行数，因而对 Prover 的性能影响不大。R1CS 电路的编码清晰简单，利于在其上构造各种 SNARK 方案。
>
> 在 2019 年 Plonk 论文中的编码方案同时需要编码加法门与乘法门，看起来因此会增加约束的数量，降低 Proving 性能。但 Plonk 团队随后陆续引入了除乘法与加法外的运算门，比如实现范围检查的门，实现异或运算的门等等。不仅如此，Plonk 支持任何其输入输出满足多项式关系的门，即 Custom Gate，还有适用于实现 RAM 的状态转换门等，随着查表门的提出，Plonk 方案逐步成为许多应用的首选方案，其编码方式也有了一个专门的名词：Plonkish。
> 
>
> R1CS 的 (𝑈,𝑉,𝑊) 表格的宽度与引线的数量有关，行数跟乘法门数量有关。这个构造相当于把算术电路看成是仅有乘法门构成，但每个门有多个输入引脚（最多为所有引线的数量）。而 Plonkish 则是同等对待加法门与乘法门，并且因为输入引脚只有两个， 所以 𝑊 表格的宽度固定，仅有三列（如果要支持高级的计算门，表格可以扩展到更多列）。这一特性是 Plonk 可以利用 Permutation Argument 实现拷贝约束的前提。
>
>> ..., and thus our linear contraints are just wiring constraints that can be reduced to a permutation check.
>
> 按照 Plonk 论文的统计，一般情况下，算术电路中加法门的数量是乘法门的两倍。如果这样看来， 𝑊 表格的长度会三倍于 R1CS 的矩阵。但这个让步会带来更多的算术化灵活度。

## PLONK 2. 多项式编码

第一阶段，将每个列向量借助拉格朗日插值法等价转为多项式。在这个阶段，对于 Plonk，我们有 $W$ 对应的多项式 $P_{W_L}, P_{W_R}, P_{W_O}, P_{Q_L}, .., P_{Q_O}$。注意，这些列向量和对应的多项式是等价且双向的，知道 $P_{W_L}$ 也能推导出 $W_L$。所以，在这个阶段，$P_{W_L}, P_{W_R}, P_{W_O}$ 是秘密知识，$P_{Q_L}, .., P_{Q_O}$ 是公开参数。这个阶段的 Proof是「我知道一组 $W$ 对应的多项式 $P_W(X)$，它能满足 $P_{Q}(X)$ 约束 」
第二阶段，
第三阶段，合并上面的所有多项式，将上述多有的多项式约束压缩成一个大多项式 **big polynomial**。这个阶段的 Proof 和公开参数和秘密知识 是==「？」==
第四阶段，引入 [[零知识证明 ZKP#多项式随机挑战和 Schwartz-Zippel 定理]]。这个阶段的 Proof 和公开参数和秘密知识 是==「？」==「verifier 提供一个随机数 $x$，我算出来一个 $y$，如果结果匹配，那就证明我知道 **big polynomial**（？或者说是我知道 $P_W(X)$？）」
第五阶段，引入同态加密和多项式承诺 commitment。这个阶段的公开参数是 commitment，秘密知识是 **big polynomial**， Proof 是==「？」==


第一阶段是将列向量等价转为多项式，这个阶段可以用「[系数编码法](https://github.com/sec-bit/learning-zkp/blob/develop/plonk-intro-zh/2-plonk-lagrange-basis.md#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E6%A6%82%E7%8E%87%E6%A3%80%E6%9F%A5)」、「拉格朗日插值法」等编码方案，反正得出的多项式都是同一个。
这里介绍拉格朗日插值法，
关于选点技巧，参考 [单位根 Roots of Unity](https://github.com/sec-bit/learning-zkp/blob/develop/plonk-intro-zh/2-plonk-lagrange-basis.md#%E5%8D%95%E4%BD%8D%E6%A0%B9-roots-of-unity)；
关于拉格朗日插值法的原理，请参考 [[零知识证明 ZKP#密码学前置知识：多项式的值表达 等价于 多项式的系数表达]] ；
关于操作步骤，假设共有4组约束，以 $\vec{Q_L}$ 为例，我们要构造多项式 $P_{Q_L}(X)$，使得它在定义域 $\mathbb{H} = (w_0, w_1, \ldots w_{N-1})$ 上的取值为 $\vec{Q_L}$。选出 4 组点 $[(0, Q_{L_1}), (1, Q_{L_2}), (2, Q_{L_3}), (3, Q_{L_4})]$ ，即 $H = \set{0,1,2,3}$。将 4 组点套进拉格朗日插值公式，得到等价的多项式 $P_{Q_L}(X)$；
关于验证其等价性，代入这 4 组点，你肯定能算出 $P_{Q_L}(0) == Q_{L_1}$, ... $P_{Q_L}(3) == Q_{L_4}$，其实这个验证也说明了，知道 $P_{Q_L}$ 能反推出 $Q_L$。
$$
\begin{aligned}
&\vec{Q_L} = \begin{bmatrix} Q_{L_1} \\ Q_{L_2} \\ Q_{L_3} \\ Q_{L_4} \end{bmatrix} = (Q_{L_1}, Q_{L_2}, Q_{L_3}, Q_{L_4})
\\
\\
&P_{Q_L}(X) \equiv Q_L \text{ after } \mathit{Lagrange} \text{ Interpolation }, \quad \forall X \in \mathbb{H}, \mathbb{H} = \set{0, 1, 2, 3}
\\
\\
&P(X) = P_{Q_L}(X)*P_{W_L}(X) + P_{Q_R}(X)*P_{W_R}(X) + P_{Q_M}*(P_{W_L}(X)*P_{W_R}(X)) + P_{Q_C}(X) - P_{Q_O}(X)*P_{W_O}(X) = 0, \quad \forall X \in \mathbb{H}, \mathbb{H} = \set{0, 1, 2, 3}
\\
\\

Proof: &\text{Prover knows} \quad P_{W_*} \text{ such that} \quad P(X) = 0, \quad \forall X \in \mathbb{H} \\
&P_{W_*} \quad \text{are secret}, (P_{Q_*}, H) \quad \text{are public}
\end{aligned}
$$
总结：我们将矩阵等式等价转为了多项式等式，秘密知识是 $P_{W_*}$，公共参数是 $(P_{Q_*}, \mathbb{H})$，目标是证明 Prover 知晓 $P_{W_*}$ 使得仅当 $\forall X \in \mathbb{H}$ 时， $P(X) = 0$ 成立。
再次强调，仅当 $\forall X \in \mathbb{H}$ 时，$P(X) = 0$ 才成立。

第二阶段。
在这个阶段，放开 $X$ 地定义域，$\forall X \in \mathbb{H}$ 改为 $\forall X \in \mathbb{F}$（[暂时理解](https://github.com/sec-bit/learning-zkp/blob/develop/plonk-intro-zh/2-plonk-lagrange-basis.md#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E6%A6%82%E7%8E%87%E6%A3%80%E6%9F%A5) $\mathbb{F}$ 是椭圆曲线上的有限整数域吧）；相应地，调整 $P(X)$ 的型态，得到：

$$P(X) = q(X) \cdot Z_H(X), \quad \forall X \in \mathbb{F}$$
其中，
$Z_H(X)$ 为 $P(X)$ 的零多项式 Vanishing Polynomial，$q(X)$ 为 $P(X)$ 的商多项式 Quotient Polynomial；
由 $P(X) = 0, \forall X \in \mathbb{H}$ 可知，$\mathbb{H}$ 就是 $P(X)$ 的「根集合」，易得 $Z_H(X) = (X-w_0)*(X-w_1)..(X-w_{N-1})$，也易算出 $q(X) = P(X) / Z_H(X)$。

得到相应的 Proof 型态：
$$
\begin{aligned}
& \text{Proof: } \text{Prover knows} \quad P_{W_*} \text{ such that } \quad  q(X) \cdot Z_H(X) = P_{Q_L}(X)*P_{W_L}(X) + P_{Q_R}(X)*P_{W_R}(X) + P_{Q_M}*(P_{W_L}(X)*P_{W_R}(X)) + P_{Q_C}(X) - P_{Q_O}(X)*P_{W_O}(X), \quad \forall X \in \mathbb{F} \\

& P_{W_*} \text{ are secret, } (P_{Q_*}, \mathbb{H}, Z_H, q) \text{ are public}

\end{aligned}
$$

总结：
- ==秘密知识是== $P_{W_*}$，==公共参数是== $(P_{Q_*}, \mathbb{H}, Z_H, q)$
	- 其实知晓 $\mathbb{H}$ 等价于知晓 $Z_H(X)$，但反过来不行；
	- 根据公共参数，Verifier 可以自行代入数值 $X = w \in \mathbb{H}$ 得到 $P(w) = 0$，并且代入其它数值 $X \in \mathbb{F} \text{ and } X \notin \mathbb{H}$ 得到 $P(X) \neq 0$.
- ==目标是==证明 Prover 知晓 $P_{W_*}$ 使得 $q(X)\cdot Z_H(X) == P_{Q_L}(X)*P_{W_L}(X) + P_{Q_R}(X)*P_{W_R}(X) + P_{Q_M}*(P_{W_L}(X)*P_{W_R}(X)) + P_{Q_C}(X) - P_{Q_O}(X)*P_{W_O}(X)$
 








### 第一阶段：列向量 $\rightarrow$ 多项式

我们采用拉格朗日插值法来将列向量等价转为多项式。如果我们要构造多项式 $a(X)$，使得它在定义域 $H=(w_0, w_1, \ldots w_{N-1})$ 上的取值为 $\vec{a}$。在很多教程里，$(w_0, .., w_{N-1})$ 都直接取值为 $(0, 1, 2, .., n-1)$，对于教程而言，这样取值更好阐述，但是实际应用的时候会选择一些特别的点。

> ==其实我不太能理解 $H$ 的定义，因为原始问题 $a(\zeta)+b(\zeta)\overset{?}{=}c(\zeta)$ 是没有定义域的，为什么映射到这儿就能新定义个 「定义域 $H$」？==
> 我觉得理解为什么它能新搞出个「定义域 H」很重要，之前我看好多文章都说解释过，直接就用定义 $X = (0, w_0), (1, w_1), .. (n-1, w_{n-1})$ 我觉得很不能理解。

使用 Lagrange Basic 得到的 Lagrange Polynomials 在定义域 $H$ 上也符合映射关系，也能有相应的加法和乘法操作。但如果直接让 Verifier 发送随机数 $\zeta$ 挑战，**那么 $\zeta$ 只能属于 $H$**。如果只存在一个 $j$ 使得 $a_j\cdot b_j\neq c_j$，那么 Verifier 的一次挑战能发现这个**错误的概率只有 $\frac{1}{|n|}$**，这样 Verifier 需要挑战多次才能缩小检测出错的概率。我们还可以进一步地，**只通过一次挑战来检测出 Prover 的作弊行为**。
再总结一下，由于我们之前的映射保留了定义域为 $H=(w_0, w_1, \ldots w_{N-1})$，而定义域就限制了随机性挑战的随机数的范围，即随机数 $\zeta$  只能在 $H$ 的范围内。而因为 $H$ 比较小，所以随机性挑战的置信率较低。下面方法的方向是扩大 $X$ 的定义域，使得随机数挑战的置信率提高，这样我们就能利用随机性挑战来做到 **只通过一次挑战来检测出 Prover 的作弊行为**。
强调一下，随机性挑战的目标是检测出 Prover 的作弊行为。

1. 我们可以把上面的等式的 $X$ 取值范围去除，原始的定义域为 $H=(w_0, w_1, \ldots w_{N-1})$，$\quad\forall X\in \mathbb{H}$ 扩展为 $\quad\forall X\in \mathbb{F}$，换成在整个 $\mathbb{F}$ 定义域上都成立的等式：
$$
a(X)\cdot b(X) - c(X) = q(X)\cdot z_H(X), \quad\forall X\in \mathbb{F}
$$

2.  定义 $f(X) = a(X)\cdot b(X)-c(X)$。我们可以看到 $f(X)$ 在 $X\in H$ 上等于零，那么意味着 $H$ 恰好是 $f(X)$ 的「根集合」。于是 $f(X)$ 可以按照下面的方式进行因式分解：
$$
f(X)=(X-w_0)(X-w_1)(X-w_2)\cdots(X-w_{N-1})\cdot q(X)
$$
    换个说法， $f(X)$ 可以被多项式 $z_H(X)=(X-w_0)(X-w_1)(X-w_2)\cdots(X-w_{n-1})$ 整除，并得到一个**商多项式 $q(X)$**。**零多项式 $z_H(X)$** 又被称为 Vanishing Polynomial。jj
    
3. 我们让 Prover 计算出这个 $q(X)$，并且发送给 Verifier，又因为 $H$ 是已知的系统参数，Verifier 可以自行计算 $z_H(X)$，那么 ==Verifier 只需要一次随机检测即可判断 $a(X)\cdot b(X)-c(X)$ 是否在 $H$ 处等零。（这是什么意思）==
$$
a(\zeta)\cdot b(\zeta)-c(\zeta) \overset{?}{=} q(\zeta)\cdot z_H(\zeta)
$$
4. 可选地，进一步，如果我们使用多项式承诺（Polynomial Commitment），Verifier 可以让 Prover 来帮忙计算这些多项式在 $X=\zeta$ 处的取值，发送并证明这些值的正确性，这样能最大限度地减少 Verifier 的工作量。

5. 可选地，进一步，Verifier 计算 $z_H(\zeta)$ 需要 $O(n)$ 的计算量。那能否让 Verifier 继续减少工作量？答案是可以的，只要我们选择特殊的 $H\subset \mathbb{F}$ 。


## PLONK 3. 置换证明

「置换证明」（Permutation Argument）

### 置换证明的目标问题

如何让 Prover 证明两个长度为 $N$ 的向量 $\vec{a}$ 与 $\vec{b}$ 满足一个实现约定（公开）的置换关系 $\sigma(\cdot)$

Plonkish 电路编码用两个矩阵 $(Q,\sigma)$ 描述电路的**空白结构**，其中 $Q$ 为运算开关， $\sigma$ 为置换关系，用来约束 $W$ 矩阵中的某些位置必须被填入相等的值。为了约束 Prover 提供的 $W$ 表格满足「拷贝约束」，我们要让 Verifier 在看不到 $W$ 表格的情况下，如何仅通过一次随机挑战就能完成 𝑊 表格中多个拷贝关系的证明。
总结一下目标：
- 公开参数：$Q$ 为运算开关， $\sigma$ 为置换关系
- 秘密参数：$W$
- Proof：$W$ 进行 $\sigma$ 置换后，依旧等于 $W$
- 要求：验证的成本尽可能地低

### 置换证明的思路概要

**首先，我们简化一下问题：如何证明两个等长向量 $\vec{a}$ 和 $\vec{a}'$ 满足一个已知的置换 $\sigma$，并且 $\vec{a}=\vec{a}'$**

然后，将该问题再拆解为两个子问题：
- 如何证明两个等长向量 **Multiset 等价**？解法：(1) 先用连乘证明证「乘积满足关系」；(2) 再引入随机数来大概率保证「若 $\vec{a} - \gamma * \vec{I}$ 和 $\vec{b} - \gamma * \vec{I}$ 的乘积相等，则说明 $\vec{a} == \vec{b}$」
- 如何证明两个等长向量 **满足置换关系** $\sigma$？解法：将置换关系代入多项式，再发起随机挑战

### 一、连乘证明和「乘积满足关系」

**连乘证明（Grand Product）**：
假设我们要证明下面的「连乘关系」 ：

$$
b = a_1\cdot a_2 \cdot a_3 \cdot \cdots \cdot a_{n-1}
$$
这里对付连乘的基本思路是：让 Prover 利用一组单乘的证明来实现多个数的连乘证明，然后再通过多项式的编码，交给 Verifier 进行概率检查。强调下：思路中的关键点是如何把一个连乘计算转换成多次的单乘计算。

1. 调整 **多数连乘约束**，以及定义 $\vec{a} = [a_0=\frac{1}{b}, a_1, \cdots, a_{n-1}]$，$\vec{r} = [r_0=1,r_1,\cdots,r_{n-1}]$
      $$
   \begin{aligned}
   1 = \frac{1}{b} \cdot a_1\cdot a_2 \cdot a_3 \cdot \cdots \cdot a_{n-1}
   \end{aligned}
   $$
2. 转为等价的 **多组单乘约束**：
  $$
  \begin{aligned}
  \frac{1}{b} &\cdot 1 &= r_1 \\
  a_1 &\cdot r_1 &= r_2 \\
  a_2 &\cdot r_2 &= r_3 \\
  &\cdot \\
  &\cdot \\
  a_{n-1} &\cdot r_{n-1} &=1
  \end{aligned}
  $$
3. 表达为等价的 **递归式约束**：
   $$
   \begin{aligned}
   r_0 &= 1 \\
   r_i &= a_{i-1} \cdot r_{i-1} \quad 1 \le i \le n-1
   \end{aligned}
   $$

5. 转为等价的 **递归多项式约束**：
   $$
   \begin{aligned}
   L_0(X) \cdot (r(X) - 1) &= 0, &\forall X \in \mathbb{H} \\
   a(X) \cdot r(X) &= r(\omega \cdot X), &\forall X \in \mathbb{H}
   \end{aligned}
   $$
6. 引入随机数 $\alpha$ 将上述两组递归多项式约束 **合并** 为一个递归多项式约束：
   $$
   \begin{aligned}
   L_0(X) \cdot (r(X) - 1) + \alpha \cdot (a(X) \cdot r(X) - r(\omega \cdot X)) = 0, \quad \forall X \in \mathbb{H}
   \end{aligned}
   $$

7. 扩宽定义域 $X \in \mathbb{F}$：
   $$
   \begin{aligned}
   L_0(X) \cdot (r(X) - 1) + \alpha \cdot (a(X) \cdot r(X) - r(\omega \cdot X)) = Z_H(X) \cdot q(X), \quad \forall X \in \mathbb{F}
   \end{aligned}
   $$ 
8. 接下来，通过 Schwartz-Zippel 定理，Verifier 可以给出挑战数 $\zeta$ 来验证上述多项式等式是否成立。  

> [!hint] 
> 其实证明两个向量「Multiset 等价」，有很多种方式。
> 
> 比如揭露整个多项式、比如用 R1CS、比如哈希化、比如默克尔树化再概率性检查叶子结点，但是这些方式中，”先转为连乘，再转为多项式，最后用 Schwitz-Zippel lemma“ 的方式最为简洁。
>
> 零知识证明跟一般问题不同，在零知识证明中，Verifier 只想知道 “prover **是否** 知道正确的秘密”，而不想知道“秘密是什么”。

### 二、从「乘积满足关系」到「Multiset 等价证明」

假设有两个向量，其中一个向量是另一个向量的乱序重排，那么如何证明它们在集合意义（注意：集合无序）上的等价呢？

我们假设向量 $\\{q_i\\}$  为一个多项式 $q(X)$ 的根集合，即对向量中的任何一个元素 $q_i$，都满足  $q(r_i)=0$。这个多项式可以定义为：

$$
q(X) = (X-q_0)(X-q_1)(X-q_2)\cdots (X-q_{n-1})
$$

如果存在另一个多项式 $p(X)$ 等于 $q(X)$，那么它们一定具有相同的根集合 $\\{q_i\\}$。比如

$$
\prod_{i}(X - q_i) = q(X) = p(X) = \prod_{i}(X - p_i)
$$

那么

$$
\\{q_i\\}=_{multiset}\\{p_i\\}
$$
我们可以利用 Schwartz-Zippel 定理来进一步地检验：向 Verifier 索要一个随机数 $\gamma$，那么 Prover 就可以通过下面的等式证明两个向量 $\\{p_i\\}$ 与 $\\{q_i\\}$ 在多重集合意义上等价：

$$
\prod_{{i\in[n]}}(\gamma-p_i)=\prod_{i\in[n]}(\gamma-q_i) 
$$
$$
\prod_{{i\in[n]}}\frac{(\gamma-p_i)}{(\gamma-q_i)}=1
$$

到这里，我们已经明白如何证明「Multiset 等价」，下一步我们将完成构造「置换证明」（Permutation Argument），用来实现协议所需的「Copy Constraints」。

### 三、从 「Multiset 等价」到「置换证明」

如果两个向量 𝑎→ 与 𝑏→ 满足 𝜎 置换，那么，合并后的两个向量 𝑎→′ 和 𝑏→′ 将满足 Multiset 等价关系。

也就是说，通过把向量和位置值合并，就能够把一个「置换证明」转换成一个「多重集合等价证明」，即不用再针对某个特定的「置换关系」进行证明。

向 Verifier 索取一个随机数 $\beta$，把“向量元素”和“向量位置”「折叠」成一个值：$a'_i=(a_i+\beta\cdot i) \quad \quad b_i'=(b + \beta\cdot \sigma(i))$

接下来，Prover 可以对 $\vec{a}'$ 与 $\vec{b}'$ 两个向量进行 Multiset 等价证明，从而可以证明它们的置换关系。

### 四、完整的置换证明协议

https://github.com/sec-bit/learning-zkp/blob/master/plonk-intro-cn/3-plonk-permutation.md#%E5%AE%8C%E6%95%B4%E7%9A%84%E7%BD%AE%E6%8D%A2%E5%8D%8F%E8%AE%AE

$$
\begin{aligned}
& \text{Input  } \vec{a}, \vec{b}, \sigma.
\\\\
& z_o = 1, \quad z_{i+1} = z{i} \cdot \frac{(a_i + \beta \cdot i + \gamma)}{(b_i + \beta \cdot \sigma(i) + \gamma)}
\\

& \begin{equation}
f(i) = \begin{cases}
z(i) - 1 & \text{if i = 0}, \\
z(i+1)\cdot(b_i + \beta \cdot \sigma(i) + \gamma) - z(i) \cdot (a_i + \beta \cdot i + \gamma) & \text{if i } \ne 0
\end{cases}
\end{equation}

\\\\

& f(x) = \begin{cases}
L_0(x) \cdot (z(x) - 1) & \text{if } x = \omega^1, \\
z(\omega \cdot x)\cdot(b(x) + \beta \cdot \sigma(x) + \gamma) - z(x) \cdot (a(x) + \beta \cdot id(x) + \gamma) & \text{if } x \ne \omega^1.
\end{cases}

\\\\

& f(x) = L_0(x) \cdot (z(x) - 1) + \alpha \cdot (z(\omega \cdot x)\cdot(b(x) + \beta \cdot \sigma(x) + \gamma) - z(x) \cdot (a(x) + \beta \cdot id(x) + \gamma))
\\
& f(x) = q(x) \cdot Vanishing(x)
\\\\
& \text{Verifier provide } \zeta, \\
& \text{Prover prove } a(\zeta), b(\zeta), q(\zeta), z(\zeta), z(\omega \cdot \zeta), id(\zeta), \sigma(\zeta) \\
& \text{Verifier verify} L_0(\zeta) \cdot (z(\zeta) - 1) + \alpha \cdot (z(\omega \cdot \zeta)\cdot(b(\zeta) + \beta \cdot \sigma(\zeta) + \gamma) - z(\zeta) \cdot (a(\zeta) + \beta \cdot id(\zeta) + \gamma)) \overset{?}{=} q(\zeta) \cdot Vanishing(\zeta)
\end{aligned}
$$

### 五、总结置换证明

[回顾置换证明](https://github.com/sec-bit/learning-zkp/blob/master/plonk-intro-cn/4-plonk-constraints.md)

上一节，我们讨论了如何让 Prover 证明两个长度为 $N$ 的向量 $\vec{a}$ 与 $\vec{b}$ 满足一个实现约定（公开）的置换关系 $\sigma(\cdot)$，即
$$
a_i = b_{\sigma(i)}
$$

基本思路是向 Verifier 要一个随机数 $\beta$，把两个「原始向量」和他们的「位置向量」进行合体，产生出两个新的向量，记为 $\vec{a}'$ 与 $\vec{b}'$
$$
a'_i = a_i + \beta \cdot i, \qquad b_i'=b_i+\beta\cdot \sigma(i)
$$

第二步是再向 Verifier 要一个随机数 $\gamma$，通过连乘的方法来编码 $\vec{a}'$ 和 $\vec{b}'$ 的 Multiset，记为 $A$ 和 $B$：
$$
A = \prod(a'_i + \gamma),\qquad B = \prod(b'_i + \gamma)
$$

第三步是让 Prover 证明 $A/B=1$，即
$$
\prod_i\frac{(a'_i + \gamma)}{(b_i'+\gamma)} = 1
$$

证明这个连乘，需要引入一个辅助向量 $\vec{z}$，记录每次乘法运算的中间结果：
$$
z_0=1, \qquad z_{i+1}=z_i\cdot \frac{(a'_i+\gamma)}{(b'_i+\gamma)}
$$

由于 $z_N=\prod\frac{a'_i+\gamma}{b'_i+\gamma}= z_0 = 1$，而且 $\omega^N=1$，==因此我们可以用== $z(X)$ 来编码 $\vec{z}$（先根据 $\vec{z}$ 的表示算出 $z_0, \cdots, z_n$ 的点值，再套用拉格朗日插值法。$z_i$ 的点值在 [这里有写](https://github.com/sec-bit/learning-zkp/blob/master/plonk-intro-cn/4-plonk-constraints.md#%E5%A4%9A%E4%B8%AA%E5%90%91%E9%87%8F%E9%97%B4%E7%9A%84%E6%8B%B7%E8%B4%9D%E7%BA%A6%E6%9D%9F) ，$z_{n-1} = \frac{f_0f_1\cdots f_{N-3}}{g_0g_1\cdots g_{N-3}}\cdot \frac{f_{N-2}}{g_{N-2}}$，$z(X)$ 的拉格朗日插值法表示形式在 [这里有写](https://github.com/sec-bit/learning-zkp/blob/master/plonk-intro-cn/7-plonk-lookup.md#%E5%8D%8F%E8%AE%AE%E6%A1%86%E6%9E%B6) $z(X)=L_0(X) + \sum_{i=1}^{N-1}\Big(L_{i}(X)\cdot \prod_{j=0}^{i-1}\frac{(f_i+\gamma_1)(t_i+\gamma_2)}{(f'_i+\gamma_1)(t'_i+\gamma_2)}\Big)$），==从而把置换证明转换成关于== $z(X), a(X)$ 的关系证明。

最后 Verifier 发送挑战数 $\zeta$，得到 $z(\zeta), z(\omega\cdot\zeta), a(\zeta), b(\zeta)$  然后检查它们之间的关系。

> [!note] 理解 $z(X)$：
> 1. 我们先是构造了 $\vec{z}$ 向量
>    $$z_0=1, \qquad z_{i+1}=z_i\cdot \frac{(a'_i+\gamma)}{(b'_i+\gamma)} \quad \forall i \in [0, N-1]$$
> 
> 2. 由于 $z_0 = z_N = 1$，是个**循环群（Cyclic Group）**。我们可以扩大其定义域 
>    $$z_0=1, \qquad z_{i+1}=z_i\cdot \frac{(a'_i+\gamma)}{(b'_i+\gamma)} \quad \forall i \in Z$$
> 
> 3. 为了能采用随机挑战 Schwartz-Zippel 引理，进一步扩大其定义域
>    $$z(X) = q(X)\cdot Valishing(X), \quad \forall X \in R$$
>
> 4. 挑选 $\omega$，使得 $\omega^N = 1$，这样就能简化 $Valishing(X)$ 多项式
>    
>> 这里的 $z(X)$ 即置换关系证明，$a(X)$ 即 Plonk 的 $W$ 矩阵约束，二者结合，就是我们要的置换约束或拷贝约束。


### 六、自我总结版

回顾 [[零知识证明 ZKP#置换证明的目标问题]]：如何让 Prover 证明两个长度为 $N$ 的向量 $\vec{a}$ 与 $\vec{b}$ 满足一个实现约定（公开）的置换关系 $\sigma(\cdot)$

思路：「表格置换问题」转为「向量相等问题」，「向量相等问题」转为「集合相等问题」，再通过连乘证明解决「集合相等问题」。
1. 「表格置换问题」转为「向量相等问题」。 用向量的下标表达置换。
2. 「向量相等问题」转为「集合相等问题」。**把向量元素的下标也作为集合元素的一部分**，就将「有序向量元素」转为「无序集合元素」了。为了保留信息，引入随机数做折叠，参考 [[零知识证明 ZKP#FAQ 引入随机数来折叠多项式的目的？]]。
3. 解决「集合相等问题」。直接让集合元素相乘/相减，并不能证明两个集合相等，比如 2 x 8 = 4 x 4 的情况。为此，我们**给集合元素加点盐------随机数**，(2 + salt) x (8 + salt) = (4 + salt) x (4 + salt)。加盐后再连乘，就能极大概率证明「集合相等问题」


### FAQ 引入随机数来折叠多项式的目的？

> [!faq] [「理解 PLONK（三）：置换证明」引入随机数的目的](https://github.com/Antalpha-Labs/zkp-academy/discussions/13)
> [「理解 PLONK（三）：置换证明」](https://github.com/sec-bit/learning-zkp/edit/develop/plonk-intro-zh/3-plonk-permutation.md)中，完整的置换协议引入了三个新的随机数 $\alpha$ 、 $\gamma$ 、 $\beta$ ：
> 
> - 连乘证明引入随机数 $\alpha$：
>     > 其中 $\alpha$ 是用来聚合多个多项式约束的随机挑战数。  $L_0(X)\cdot(r(X)-1)+\alpha\cdot(q(X)\cdot r(X)-r(\omega\cdot X))=h(X)\cdot z_H(X)$ 
> 
> - Multiset 等价证明引入随机数 $\gamma$
>     > 我们可以利用 Schwartz-Zippel 定理来进一步地检验：向 Verifier 索要一个随机数 $\gamma$，那么 Prover 就可以通过下面的等式证明两个向量 $\\{p_i\\}$ 与 $\\{q_i\\}$ 在多重集合意义上等价： $\prod_{{i\in[n]}}(\gamma-p_i)=\prod_{i\in[n]}(\gamma-q_i)$
> 
> - 置换证明引入随机数 $\beta$
>     > 我们再使用一个技巧：再向 Verifier 索取一个随机数 $\beta$，把一个元组「折叠」成一个值：
> 
> $$
> \begin{array}{|c|c|}
> a'_i=(a_i+\beta\cdot i) & b_i'=(b + \beta\cdot \sigma(i)) \\
> \hline
> (a_0 + \beta\cdot 0) & (b_0 + \beta\cdot 1) \\
> (a_1 + \beta\cdot 1) & (b_1 + \beta\cdot 0) \\
> \vdots & \vdots \\
> (a\_{n-1} + \beta\cdot n-1) & (b\_{n-1} + \beta\cdot n) \\
> (a\_n + \beta\cdot n) & (b\_n + \beta\cdot (n-1))\\
> \end{array}
> $$
> 
> 
> 我的疑惑：
> 1. 连乘证明在聚合多个多项式约束时，为什么一定要引入随机数  $\alpha$ ？直接聚合 $L_0(X)\cdot(r(X)-1)+ (q(X)\cdot r(X)-r(\omega\cdot X))=h(X)\cdot z_H(X)$ 会有什么问题？以及，为什么文中的第一个式子没有乘上 $\alpha$ （我理解应该是 「 $\alpha \cdot L_0(X)\cdot(r(X)-1)$ 」 ）
> 
> 2. 置换证明在折叠元组时，为什么一定要引入随机数 $\beta$？直接折叠 $a'_i = (a_i + i) \quad  b_i'=(b + \sigma(i))$ 会有什么问题？
> 
> 3. 上述三个随机数 $\alpha$、 $\gamma$、 $\beta$ 能否都使用同一个数值？
> 
>> [!hint] WangYao 老师的回答
>> Degree 是一个多项式的很重要的信息，也代表着多项式所能携带的信息量。
>> 当我们直接让两个多项式相加时，这两个多项式可能会有抵消项，也就是某些 degree 信息被丢失了。用数学方法表示，  $|f(x)|=d, |g(x)|=d, |f(x)+g(x)| \le d$ 。
>> 为了保留多项式的原始信息，我们在做多项式的线性组合时，会引入一个随机系数。
>> 
>> [[零知识证明 ZKP#Pedersen 承诺的性质]] 里提到，Pesersen 将多个椭圆曲线点汇总到一个多项式内，但由于椭圆曲线点和运算的正交性，使得虽然多个点汇总到一个多项式内，但是每个点及其相关的运算又相互正交。我觉得这本质上跟 Plonk 里引入随机数把多个多项式折叠到一起是一样的。

## PLONK.4 拷贝约束

这节课在上一节「置换证明」的基础上，补充了一些细节（比如多个变量的置换关系 $\sigma$ 的表示方式、$W$ 在置换前后对应的连乘式 $f(x), g(x)$、引入 $\phi(X)$ 处理公开输入），以及给出完整的协议框架。

### 一、协议框架

预处理：Prover 和 Verifier 构造 $[Q_L(X)]$， $[Q_R(X)]$， $[Q_O(X)]$， $[Q_M(X)]$， $[Q_C(X)]$， $[{\sigma_L}(X)]$， $[{\sigma_R}(X)]$， $[{\sigma_O}(X)]$

第一步：（算术约束）Prover 针对 $W$ 表格的每一列，构造 $[W_L(X)]$， $[W_R(X)]$， $[W_O(X)]$， $\phi(X)$ 使得

$$
Q_L(X)W_L(X)+Q_R(X)W_R(X)+ Q_M(X)W_L(X)W_R(X) - Q_O(X)W_O(X)+Q_C(X) + \phi(X) = 0
$$
第二步： Verifier 发送随机数 $\beta$ 与 $\gamma$；

第三步：（拷贝约束）Prover 构造 $[z(X)]$，[使得满足下方约束。具体方法](https://github.com/sec-bit/learning-zkp/blob/master/plonk-intro-cn/4-plonk-constraints.md#%E5%A4%9A%E4%B8%AA%E5%90%91%E9%87%8F%E9%97%B4%E7%9A%84%E6%8B%B7%E8%B4%9D%E7%BA%A6%E6%9D%9F) 是算出 $z(X)$ 在 $\omega^0, \omega^1, \cdots, \omega^{N-1}$ 的取值，**再套用拉格朗日插值法。** 在 https://github.com/sec-bit/learning-zkp/blob/master/plonk-intro-cn/7-plonk-lookup.md#%E5%8D%8F%E8%AE%AE%E6%A1%86%E6%9E%B6 halo2-lookup 的协议框架里有展示 z(X) 的样子，就是拉格朗日插值法的样子。

$$
\begin{split}
L_0(X)(z(X)-1) &= 0 \\
z(\omega\cdot X)g(X) -  z(X)f(X) &=0 \\
\end{split}
$$

其中 $f(x), g(x)$ 是关于 $W$ 置换证明的连乘式：
$$
\begin{split}
f(X) &= (W_L(X) + \beta \cdot id_L(X) + \gamma) \cdot (W_R(X) + \beta \cdot id_R(X) + \gamma) \cdot (W_O(X) + \beta \cdot id_O(X) + \gamma) \\
g(X) &= (W_L(X) + \beta \cdot \sigma_L(X) + \gamma) \cdot (W_R(X) + \beta \cdot \sigma_R(X) + \gamma) \cdot (W_O(X) + \beta \cdot \sigma_O(X) + \gamma)
\end{split}
$$

第四步：Verifier 发送随机挑战数 $\alpha$；

第五步：（合并第一步的算术约束和第三步的拷贝约束）Prover 计算 $h(X)$，并构造商多项式 $[t(X)]$

$$
\begin{split}
h(X) = &\ Q_L(X)W_L(X)+Q_R(X)W_R(X)+ Q_M(X)W_L(X)W_R(X) - Q_O(X)W_O(X)+Q_C(X) + \phi(X) \\
 & + \alpha \cdot (z(\omega X)\cdot g(X)-z(X)\cdot f(X)) + \alpha^2 \cdot (L_0(X)\cdot(z(X)-1))
\end{split}
$$

其中商多项式 $t(X)=\frac{h(X)}{z_H(X)}$ ；


第六步：Verifier 发送随机挑战数 $\zeta$，查询上述的所有 Oracle，得到
- $\bar{w}_L=W_L(\zeta)$， $\bar{w}_R=W_R(\zeta)$， $\bar{w}_O=W_O(\zeta)$
- $\bar{q}_L=Q_L(\zeta)$， $\bar{q}_R=Q_R(\zeta)$， $\bar{q}_M=Q_M(\zeta)$，  $\bar{q}_O=Q_O(\zeta)$， $\bar{q}_O=Q_O(\zeta)$
- $\bar{\sigma}_L=\sigma_L(\zeta)$， $\bar{\sigma}_R=\sigma_R(\zeta)$， $\bar{\sigma}_O=\sigma_O(\zeta)$
- $\bar{z}\_{(\omega\cdot\zeta)}=z(\omega\cdot\zeta)$， $\bar{z}_{(\zeta)}=z(\zeta)$
- $\bar{t}=t(\zeta)$

Verifier 还要自行计算
- $\bar{f}_{(\zeta)} =(\bar{w}_L+\beta\cdot \zeta + \gamma) (\bar{w}_R+\beta\cdot k_1\cdot \zeta +\gamma)(\bar{w}_O+\beta\cdot k_2 \cdot \zeta +\gamma)$
- $\bar{g}_{(\zeta)}=(\bar{w}_L+\beta\cdot \bar{\sigma}_1 + \gamma) (\bar{w}_R+\beta\cdot\bar{\sigma}_2+\gamma)(\bar{w}_O+\beta\cdot\bar{\sigma}_3+\gamma)$
- $L_0(\zeta)$
- $z_H(\zeta)$
- $\phi(\zeta)$

最终验证等式：
$$
\begin{split}
& \bar{q}_L\bar{w}_L+\bar{q}_R\bar{w}_R+ \bar{q}_M\bar{w}_L\bar{w}_R - \bar{q}_O\bar{w}_O+\bar{q}_O + \phi(\zeta)  \\
& \qquad \qquad + \alpha(\bar{z}\_{(\omega\cdot\zeta)}\cdot \bar{g}\_{(\zeta)}-\bar{z}\_{(\zeta)}\cdot \bar{f}\_{(\zeta)})+ \alpha^2(L_0(\zeta)\cdot(\bar{z}\_{(\zeta)}-1))\overset{?}{=}\bar{t}\cdot z_H(\zeta)
\end{split}
$$


> [!hint] 2024-06-18-Tue 第一次完整地理解了 ZK 证明的过程
> Prover 先是提供**各项多项式**的承诺；
> 然后 Verifier 提供随机数 $\zeta$ ；
> 然后 Prover 提供**各项多项式**在 $X = \zeta$ 上的取值；
> 最后 Verifier 验证（1）是否对应承诺（2）是否满足最终验证等式

## PLONK.5 Lookup Gate

### Halo2-lookup 方案

问题：我们有一个表格向量 $\vec{t}=(t_0, t_1, t_2, \cdots, t\_{n-1})$，表格中不存在相同元素。然后有一个查询向量 $\vec{f}=(f_0, f_1, f_2, \cdots, f_{m-1})$，我们接下来要证明 $\vec{f}\subseteq\vec{t}$，请注意 $\vec{f}$ 中会有重复元素。

最终目标是证明 $\vec{f}\subseteq\vec{t}$。
1. 先引入 $\vec{f}'$ ，$\vec{f}'$ 和 $\vec{f}$ 在集合意义上相等；
2. 再引入 $\vec{t}'$，$\vec{t}'$ 和 $\vec{t}$ 在集合意义上相等；
3. 约束 $\vec{f}'$ 和 $\vec{t}'$ 的关系：
  $$
 \begin{split}
 (f'(X)-f'(\omega^{-1}\cdot X))\cdot (f'(X)-t'(X)) = 0, \quad \forall x\in H \\
 L_0(X)\cdot(f'(X)-t'(X)) = 0, \quad \forall x\in H
 \end{split}
 $$
4. 约束 $\vec{f}$ 和 $\vec{f}'$ 满足置换关系，约束 $\vec{t}$ 和 $\vec{t}'$ 满足置换关系，即集合意义上相等
   $$
   \begin{split}
   \frac{z(\omega\cdot X)}{z(X)}=\frac{(f(X)+\gamma_1)(t(X)+\gamma_2)}{(f'(X)+\gamma_1)(t'(X)+\gamma_2)}
   \\
   L_0(X)\cdot (z(X) - 1) = 0, \quad \forall x\in H
   \end{split}
   $$

注意，在协议框架一节里，第三步给出了 $z(X)$ 的拉格朗日插值法表达形式，就是 $L_0(X) * z_0 + \cdots + L_n(X) * z_n$，其中 [这里有写](https://github.com/sec-bit/learning-zkp/blob/master/plonk-intro-cn/7-plonk-lookup.md#%E5%8D%8F%E8%AE%AE%E6%A1%86%E6%9E%B6) $z_{n-1} = \frac{f_0f_1\cdots f_{N-3}}{g_0g_1\cdots g_{N-3}}\cdot \frac{f_{N-2}}{g_{N-2}}$


## Python

```
# 1. 创建虚拟环境
python3 -m venv myenv

# 2. 激活虚拟环境
source /Users/keroro520/workspace/python-workspace/myenv/bin/activate

# 3. 在虚拟环境中安装NumPy：
pip install numpy scipy matplotlib
```

```
poetry install
```

> [!failure] Current Python version (3.12.2) is not allowed by the project (>=3.9,<3.12).
>
>> ```
>> pyenv install 3.11.3
>> pyenv local 3.11.3
>> poetry env use 3.11.3
>> ```


## 密码学前置知识

> [!seealso] 
> - [星辰实验室 P1: 零知识证明 与 zk-SNARK](https://youtu.be/TQjzKAkHFls?t=378)

- 多项式时间算法
- 非多项式时间算法
- P ≠ NP
- P 问题：在多项式时间内可以求解的问题
- NP 问题：在多项式时间内难以求解的问题，但是能在短时间内快速验证解是否正确
- 重要的 NP 问题：多项式整除困难问题（[[零知识证明 ZKP#密码学前置知识：计算困难问题]]）
- ==密码学的本质：==
	1. ==将**数据**放到椭圆曲线**离散对数点**上，形成**离散对数困难==**
	2. ==椭圆曲线离散对数点是**群元素**，群元素可进行**二元运算**==
- 零知识证明与zk-SNARK核心技术（照应着上述“密码学的本质”）
	- ==Prover：将**多项式整除困难问题**中 QAP/QSP 多项式、商多项式、和 $z(x)$ 这三个多项式的系数放到椭圆曲线离散对数点上（又称为**多项式承诺**），形成离散对数困难==
	- ==Verifier：对生成的椭圆曲线离散对数点进行二元运算，重构整除关系，能否快速验证**解向量 $\vec{s}$** 的正确性，却不知道解向量 $\vec{s}$ 的数值==
- ==重要命题：[[零知识证明 ZKP#密码学前置知识：多项式的值表达 等价于 多项式的系数表达 | 多项式的值表达 等价于 多项式的系数表达]]==
- 零知识证明协议的重要性质：
	- Completeness (honest prover assumed, verifier should accept)
	- Soundness (malicious prover assumed, verifier should reject)
	- Zero-knowledge (malicious verifier assumed, witness should not be computed)

## 密码学前置知识：多项式的值表达 等价于 多项式的系数表达

> [!seealso] 
> - https://youtu.be/TQjzKAkHFls?t=491

重要命题：**多项式的值表达** 等价于 **多项式的系数表达**。


 	  ![[Pasted image 20240527191712.png|500x200]] ^319a31

> [!note]
> ### 多项式的值表达与系数表达
> 
> **多项式的值表达**：指的是给定多项式 $f(x)$ 在特定点 $x_1, x_2, ..., x_n$ 上的值，即 $(x_1, f(x_1)), (x_2, f(x_2)), ..., (x_n, f(x_n))$。这些值是多项式在各个点上的函数值。
> 
> **多项式的系数表达**：指的是多项式 $f(x)$ 的系数形式，即 $f(x) = k_1x^{n-1} + k_2x^{n-2} + ... + k_{n-1}x + k_n$，这里，$k_1, k_2, ..., k_n$ 是多项式的系数。
> 
> ### 等价性说明
> 
> 命题中提到多项式的值表达等价于多项式的系数表达，意味着通过给定的多项式在一系列点上的值，我们可以唯一确定多项式的系数。换句话说，如果我们知道了多项式在 $n$ 个不同点上的值，我们就可以通过这些值来求解多项式的系数，反之亦然。
> 
> **为什么说它们是等价的？** 这是因为：
> 
> 1. **唯一性**：多项式是唯一确定的，给定 $n$ 个不同的点上的值，可以唯一确定一个 $n-1$ 次多项式。这是因为多项式的次数（最高项的次数）决定了需要多少个点的值来唯一确定它。
> 
> 2. **解的存在性**：存在有效的算法（如拉格朗日插值法、快速傅里叶变换等）可以在多项式时间内（即时间复杂度与多项式的次数成线性关系）从多项式的值推导出多项式的系数。
> 
> 3. **互逆性**：一旦我们有了多项式的系数，我们可以在任何点上计算多项式的值；同样，如果我们知道了多项式在足够多的点上的值，我们可以求解出多项式的系数。
> 
> 因此，命题强调的是，尽管从直观上看，多项式的值和系数是两种不同的表达形式，但在数学上，它们是紧密相连的，并且可以通过有效的算法相互转换。这种等价性在数值分析、计算机科学和工程领域中非常重要，因为它允许我们在不同的上下文中灵活地使用多项式的不同表达形式。

我自己对这个命题的不严谨的直观理解：我们从线性变换的思路来理解多项式等式，多项式的线性代数表示为 $\vec{x} \cdot \vec{k} = f(\vec{x})$，$\vec{x}$ 是一组向量，$\vec{k}$ 表示线性变化，$f(\vec{x})$ 表示线性变换后的结果，容易看出，知道 $\vec{x}$ 和 $f(\vec{x})$ 就能算出 $\vec{k}$ 

## 密码学前置知识：重要的 NP 问题

| 密码学常见的 NP 问题                                                                                                                        | 应用        | 补充                                                                                         |
| :---------------------------------------------------------------------------------------------------------------------------------- | :-------- | :----------------------------------------------------------------------------------------- |
| [大数分解困难问题](https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3#%E5%AF%A6%E9%9A%9B%E6%87%89%E7%94%A8) <br>$n = p * q$ | RSA 生成公私钥 |                                                                                            |
| 传统离散对数问题（DLP） <br>$g^x \equiv y \pmod{p}$                                                                                           | RSA       | “对数”这个概念指的是数学中的对数运算，即求解一个数的对数底数的幂次                                                         |
| 椭圆曲线上的离散对数困难问题（ECDLP） <br>$kP = Q$                                                                                                  | ECC       | "对数"这个概念并不是以传统数学中的对数形式出现的，而是以群论中的指数形式来定义的                                                  |
| [多项式整除困难问题](https://youtu.be/TQjzKAkHFls?t=212)<br><br>更常见的称呼是 [QAP问题](https://mp.weixin.qq.com/s/eU8mp81VhpV-g1x89-uZYA)           | zk-SNARK  | 对于 $f(x) = z(x) \cdot q(x)$，已知 $f(x)$，求 $z(x)$<br><br>![[Pasted image 20240527183625.png]] |

大数因子分解、多项式因式分解、矩阵非负分解 是 NP 困难问题。

电路满足、多项式满足问题 是 NP 问题。

离散对数、椭圆曲线上的离散对数 是 NP 问题。

## Sigma 协议

> [!seealso] 
> - https://youtu.be/TQjzKAkHFls?t=657

> [!note] 预备知识
> 1. 公钥和私钥满足**椭圆曲线离散对数关系： $Q = k \cdot G$**
> 2. 椭圆曲线离散对数困难问题：已知公钥 $Q$ 和生成元 $G$，无法在多项式时间内计算出私钥 $k$
> 3. [[零知识证明 ZKP#椭圆曲线数学]]

> [!hint] 
> 数字签名和 Sigma 协议高度相似：
>   - Sigma 证明：证明知道秘密，且秘密与 Q 满足离散对数关系
>   - 数字签名：    证明知道私钥，且私钥与 Q 满足离散对数关系
>
> 据说，Sigma 协议是个框架，Schror 协议是个基于这个框架的一个具体协议

**Sigma 零知识证明的目标：证明方知道 $k$ 且 $k$ 满足离散对数关系 $Q = k \cdot G$，但是不揭露 $k$**

步骤：
1. 系统参数：椭圆曲线生成元 $G$、公钥 $Q$
2. 承诺：Prover 选择一个随机数 $r$ （**秘密知识**），计算椭圆曲线离散对数点 $C$： $C = r \cdot G$，并发送 $C$
3. 挑战：Verifier 选择一个随机数 $e$ ，并发送 $e$
4. 响应：Prover 基于随机数 $e$ 构造**线性关系**： $z = r + e \cdot k$，并发送 $z$
5. 验证：Verifier 先计算基于 $e$ 和 $z$ 分别对应的点：$z \cdot G$ 和 $e \cdot Q$，然后验证目标线性关系 $z \cdot G \stackrel{?}{=} C + e \cdot Q$

公式展开：左边 $z \cdot G = (r + e \cdot k) \cdot G$，右边 $C + e \cdot G = r \cdot Q + e \cdot G = r \cdot k \cdot G + e \cdot G = (r + e \cdot k) \cdot G$ 
系统参数：$G$（双方均知道）
秘密知识：$r$, $k$ （仅 Prover 知道）
公开参数：$Q, C, e, z$（双方均知道）；$z \cdot G$, $e \cdot Q$ （双方均可计算出）

重点和问题：
1. Sigma 协议只能证明 $k$ 满足 $Q = k \cdot G$，其直接的范围比较狭窄。
2. 问题一：如果 Prover 不知道 $k$，能否构造出满足目标线性关系的式子？
   这个问题触及了目标线性关系式的本质，其实简化该式子会发现，我们最终要验证的是 $z \stackrel{?}{=} r + ek$。对于 Prover 而言，它知道 $r$ 和 $e$，它要做的是给出一个正确的 $z$，使得 $z$ 满足 $z \stackrel{?}{=} r + ek$。在椭圆曲线体系上，如果 Prover 不知道 $k$，那么他就不可能计算出 $z$。
   我们的目标是验证一组简单的线性关系，只是我们把这组线性关系放到椭圆曲线上，也就是变成了 $G$ 的点加和数乘，使得整个过程不可逆。
3. 问题二：如果 $r$ 泄漏，会有什么影响？
   如果 $r$ 泄漏，则由公开的 $z$, $r$, $e$ 就能根据 $z = r + ek$ 反推出 $k$，完全不涉及椭圆曲线，不涉及到 $G$

## BLS 签名与聚合签名

> [!seealso] 
> - [Hacker Dōjo 密码学04｜数字签名与KZG承](https://www.bilibili.com/video/BV17e411N7Jm/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=692)

**BLS 签名定义**：存在 $(G_1, G_2)$ 是阶都为 $p$ 的 co-GDH 群对，以及全域哈希函数 $Hash: [0,1]^* \rightarrow G_1$。

1. 密钥对生成：$pubkey = g_2^{privkey}$
2. 签名：$signature = (Hash(message))^{privkey}$
3. 验签：给定公钥 $pubkey$、消息 $message$、签名 $signature$：$e(signature, g_2) \overset{?}{=} e(Hash(message), pubkey)$
   推导：
   左边 $e(signature, g_2) = e(Hash(message), g_2)^{privkey}$
   右边 $e(Hash(message), pubkey) = e(Hash(message), g^{privkey}_2) = e(Hash(message), g_2)^{privkey}$

性质：
- 安全性低于 EdDSA 和 ECDSA，常用于区块链投票，而不用做交易签名
- short signature size
- 聚合签名与批量验签（批量验证也用到了多项式和 Schwitz-Zepple lemma）

**BLS签名拓展**：引入随机数

## Schnorr 签名

**初始化**：椭圆曲线生成元 $P$，阶为 $p$

**生成密钥对**：$pubkey = privkey \cdot P$

**签名**：对于消息 $message$，
- **选择随机数** $r$ （秘密）
- 承诺 $R = r \cdot P$
- 挑战 $e := Hash(R, privkey, message)$
- 响应 $z = (r + e \times privkey) \mod p$
- 签名为 $(R, z)$

**验证**：
- 重新计算挑战 $e := Hash(R, privkey, message)$
- 验证 $z \cdot P \overset{?}{=} R + e \cdot privkey$

本质上，Schnorr 签名是 Sigma 协议的一个具体应用。
特点：如果使用了相同的随机数 $r$，对不同的消息签名，那么别人可以根据响应 $z$ 解方程，计算出私钥 $privkey$

> [!info] 为什么比特币的 Taproot 升级引入了 Schnorr 签名
> 1. 隐私性：基于 Schnorr 的多签签名不泄漏参与方多信息
> 2. 拓展性：基于 Schnorr 的多签签名可以聚合得很小
> 3. 自由选择的随机数
> EdDSA 和 ECDSA 的 「计算随机数」 有个很大的优点，那就是对于同一条消息进行多次签名时，会输出相同的签名。
> 但是这对于区块链而言可能反而是弊端，因为如果真的有两笔交易是对同一条消息签名，第一次签名时就暴露了，之后攻击者可以复用该暴露的签名来构建第二笔交易。
> 
> 参考：
> - https://medium.com/huobi-research/why-schnorr-signature-is-hailed-as-the-biggest-technological-update-after-bitcoin-segwit-aefeff45b8a3
> - https://academy.binance.com/en/articles/what-do-schnorr-signatures-mean-for-bitcoin#Why-are-Schnorr-signatures-advantageous?



## EdDSA 签名

> **Edwards-curve Digital Signature Algorithm**

> Schnorr 签名有个严重的缺点：如果使用了相同的随机数 $r$，对不同的消息签名，那么别人可以根据响应 $z$ 解方程，计算出私钥 $privkey$。
> 而 EdDSA 正是为了弥补这个缺限而诞生。
> 
> 其实 Schnorr 和 EdDSA 的唯一区别只有一点，就是在签名时选择随机数那一步

**初始化**：椭圆曲线生成元 $P$，阶为 $p$

**生成密钥对**：$pubkey = privkey \cdot P$

**签名**：对于消息 $message$，
- **计算随机数** $r = Hash(privkey, message) \mod p$ （秘密）
- 承诺 $R = r \cdot P$
- 挑战 $e := Hash(R, privkey, message)$
- 响应 $z = (r + e \times privkey) \mod p$
- 签名为 $(R, z)$

**验证**：
- 重新计算挑战 $e := Hash(R, privkey, message)$
- 验证 $z \cdot P \overset{?}{=} R + e \cdot privkey$

特点：
- 相比于 Schnorr，由于使用计算随机数的方式，所以弥补了 Schnorr 签名的缺陷，同时，对于相同的消息能产生相同的签名

> [!info] [ECDSA、EdDSA、Ed25519 的关系](https://blog.yasking.org/a/using-ecdsa-ed25519.html)
> ECDSA 和 EdDSA 都是通用的方案，Ed25519 是 EdDSA 的特定实现
> 推荐顺序：Ed25519 是最推荐方案，在性能、安全性上都比较优秀；然后是 ECDSA；最后是 EdDSA/RSA
> ![[Pasted image 20240605154052.png|500x200]]

## ECDSA 签名

> Elliptic Curve Digital Signature Algorithm

**初始化**：椭圆曲线生成元 $P$，标量域 $\mathbb{F}_{p1}$（椭圆曲线倍点运算的范围，即 $Q = k \cdot P$ 中 $k$ 的取值范围），基域 $\mathbb{F}_{p2}$。（基域表示椭圆曲线点的 $x, y$ 的取值范围）

**生成密钥对**：$Pubkey = privkey \cdot P, \quad \quad privkey \in \mathbb{F}_{p1}$ （$Pubkey$ 也是一个点，所以首字母大写）

**签名**：对于消息 $message$，
1. 计算 $m := Hash(message) \mod |\mathbb{F}_{p1}|$
2. ~~选择随机数~~ 计算随机数 $r = Hash(privkey, message) \mod |\mathbb{F}_{p1}|$（秘密）
3. 承诺：$R = r^{-1} \cdot P$
4. 挑战：取点 $R$ 的横坐标，$R'_x = R_x \mod |\mathbb{F}_{p2}|  \mod |F_{p1}|$，$R_x$ 表示点 $R$ 的横坐标，然后用 $R'_x$ 表示横坐标取模
5. 响应： $z = r \cdot (m + R'_x \cdot privkey)$
6. 签名：$(R'_x, z)$

**验签**：对于消息 $message$，
1. 重新计算 $m := Hash(message) \mod |\mathbb{F}_{p1}|$
2. 验证 $R'_x, z \in \mathbb{F}_{p1}$
3. 计算点 $O = z^{-1}m \cdot P + z^{-1}R'_x\cdot Pubkey$
4. 取点 $O$ 的横坐标，$O'_x = O_x \mod |\mathbb{F}_{p2}| \mod |\mathbb{F}_{p1}|$，$O_x$ 表示点 $O$ 的横坐标，然后用 $O'_x$ 表示横坐标取模
5. 验证 $O'_x \overset{?}{=} R'_x$

特点：
- 相比于 Schnorr/EdDSA，ECDSA 在「响应」时多乘上了随机数 $\times r$，这就增加了难度
- 相比于 Schnorr/EdDSA，ECDSA 的「承诺」是「点的横坐标」，而不是完整的「点」，所以降低了验证算力
- 承诺时选择 $r^{-1}$ 做倍点运算，响应时选择 $r$ 做倍点运算，所以验签时可以抵消

## 承诺

>  ZK 系统大致分成两部分：电路系统和承诺系统

**一般承诺的步骤**：$f^{-1}(x)$ 是 NP 问题
1. 承诺：选择原象 $x$，计算出 $y = f(x)$，并公开 $y$
2. 打开承诺：公开原象 $x$
3. 校验：$y \overset{?}{=} f(x)$

**多项式承诺的步骤**：$f^{-1}(x)$ 是 NP 问题
1. 承诺：选择原象 $x$，计算出 $y = f(x)$，并公开 $y$
2. 多点打开或者随机打开
3. 校验多点打开或者随机打开的打开值

**多项式承诺**
多项式的系数太多了，对每个系数都打开一遍的成本太高了，于是引入了「概率校验」，校验一个或者多个随机点就够了。

## Hash 承诺

1. 承诺：公开哈希值 $h$
2. 打开承诺：公开原象 $x$
3. 校验 $h \overset{?}{=} Hash(x)$

## Merkle Tree 承诺

1. 承诺：公开 Merkle root $root$
2. 打开承诺：发送叶子结点 $leaf_i$ 和 $path_i$
3. 校验：$root \overset{?}{=} Merkle(leaf_0, leaf_1, ..., leaf_{2^n})$

缺点：打开所有的叶子结点 leaf 的开销太大
改善：基于概率思想，校验：只打开随机的 100 个 leaf，概率能达 $1/2^{100}$

## Sigma 承诺

[[零知识证明 ZKP#Sigma 协议]] 除了用在签名、零知识，也能用作承诺。
跟一般性承诺不同，Sigma 承诺使用了秘密 $\omega$ 和随机数秘密 $r$（用于隐藏 $\omega$），但是没打开，而是打开响应值 $z$。打开 $z$ 不会泄漏 $\omega$ 和 $r$

## Pedersen 承诺

> [!seealso] 
> - [Dora Dōjō & lynndell博士 | 密码学04｜数字签名与KZG承诺](https://www.bilibili.com/video/BV17e411N7Jm/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=2110)
> - https://www.btcstudy.org/2024/06/07/what-are-pedersen-commitments-and-how-they-work/
### Pedersen 承诺的定义

承诺就是将向量映射到别的域。
Pedersen 把传统的「哈希函数映射」替换成「映射椭圆曲线点」。在某种意义上，椭圆曲线的标量乘法很像哈希函数。

Pedersen 在标量乘法的基础上，引入了盲化因子（抗暴力搜索）：
$$
Commit = \omega \cdot G + salt \cdot Q, \quad \quad \omega \text{ is secret}, salt \text{ is blinding factor}
$$

**强调：虽然 $G$ 和 $Q$ 都是在相同的椭圆曲线上，[但是 Prover 并不知道这两个点的线性关系。](https://www.btcstudy.org/2024/06/07/what-are-pedersen-commitments-and-how-they-work/)** 

### Pedersen 承诺的性质

1. 同态可加
   $\text{Commit}_1 = a \cdot G + s_1 \cdot Q$
   $\text{Commit}_2 = b \cdot G + s_2 \cdot Q$
   $\text{Commit}_3 = \text{Commit}_1 + \text{Commit}_2 = a \cdot G + b \cdot G + (s_1  + s_2) \cdot Q$
   只需揭露 $(a,b,s_1+s_2)$
2. **每个椭圆曲线点都是正交维度的基**
   $a \cdot G$ 和 $s_1 \cdot G$ 相加时，二者不会「相互冲突」。可以理解为，椭圆曲线点即正交维度上点一种线性组合的基（Basis）
   
   PLONK 在置换证明时，为了不丢失多项式的信息，通过引入随机数来把两个多项式合并到一起。形式合并了，而且信息没丢失，实质内容并没有丢失。我想可能真是因为这个，所以这种承诺才具备同台运算的性质。
3. ZK 友好
   椭圆曲线的加法和乘法的电路，比哈希算法的电路要简单得多
4. Pedersen Vector Commitment 向量承诺
   即可以拓展到承诺多个向量，一个 commitment 和一个 salt，隐匿一堆秘密向量
5. 聚合承诺 $\text{Commit}_1 + \text{Commit}_2$

### [Pedersen 承诺的用途举例](https://www.bilibili.com/video/BV17e411N7Jm/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=2110)

**初始化**：椭圆曲线 $Q = \omega \cdot P$，$\omega$ 为秘密

1. 承诺：金额 $m$ 和随机数 $r$，计算 $C := m \cdot P + r \cdot Q$，发送 $P$
2. 打开承诺：发送 $m$ 和 $r$
3. 校验：$C \overset{?}{=} m \cdot P + r \cdot Q$

Pedersen 具有同态性，适用于隐私币，比如 Tornado Cash，比如 [[零知识证明 ZKP#隐私转账]]。

## KZG 承诺

> [!seealso]
> - https://github.com/sec-bit/learning-zkp/blob/master/plonk-intro-cn/5-plonk-polycom.md#kzg10-%E6%9E%84%E9%80%A0

**选择基向量**：
与 Pedersen 承诺中用的**随机基向量**相比，KZG10 多项式承诺需要用一组**具有内部代数结构的基向量**来代替。

$$
(G_0, G_1, G_2, \ldots, G_{d-1}, H_0, H_1) = (G, \chi G, \chi^2G, \ldots, \chi^{d-1}G, H, \chi H)
$$
请注意，这里的 $\chi$ 是一个可信第三方提供的随机数，也被称为 Trapdoor，需要在第三方完成 Setup 后被彻底删除。它既不能让 Verifier 知道，也不能让 Prover 知道。当 $\vec{G}$ 设置好之后， $\chi$ ==被埋入了基向量中。这样一来，从外部看，这组基向量与随机基向量难以被区分==。其中 $G\in\mathbb{G}_1$，而 $H\in\mathbb{G}_2$，并且存在双线性映射 $e\in \mathbb{G}_1\times\mathbb{G}_2\to \mathbb{G}_T$。

> [!note] 
> 虽然 KZG 的点具有代数联系，
> 但是由于 trapdoor $\chi$ 被埋掉了，任何人都不知道该数值，即这个代数联系“消失”了，从外观上 KZG 和 Pesersen 的 SRS 别无二致。

**SRS**:
- 在实际生产中，我们看到的 SRS 是一串**随机基向量**
  $$\mathsf{srs} = (G_0, G_1, G_2, \ldots, G_{d-1}, H_0, H_1)$$
- 在文章和论文中，为了方便，我们会改为代数表达 SRS
  $$\mathsf{srs}=([1]_1,[\chi]_1,[\chi^2]_1,[\chi^3]_1,\ldots,[\chi^{n-1}]_1,[1]_2,[\chi]_2)$$


**承诺多项式 $f(x)$ 的方式**：
对于一个多项式 $f(X)$ 进行 KZG10 承诺，也是对其系数向量进行承诺：
$$
\begin{split}
C_{f(X)} &= a_0 G_0 + a_1  G_1 + \cdots + a_{n-1} G_{n-1} \\\\\\
 \text{// } & = a_0  G + a_1 \chi G + \cdots + a_{n-1}\chi^{n-1} G \quad \text{// note only, } \chi \text{ is unknown}\\
 \text{// } & = f(\chi) G
\end{split}
$$

**承诺 $C_{f(X)}$ 和 $f(\zeta) = y$ 的 open 证明**：



> [!question] 
> 1. 在实践中，怎么不让 Prover 和 Verifier 知道这个随机数？
> 2. 为什么不让 Prover 和 Verifier 知道这个随机数？
> 3. 双线性映射在这里的作用是什么？

## 多项式承诺

> [!seealso] 
> - [Dora Dōjō & lynndell博士 | 密码学04｜数字签名与KZG承诺](https://www.bilibili.com/video/BV17e411N7Jm/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=2110)
> - [理解 Plonk（五）：多项式承诺](https://github.com/sec-bit/learning-zkp/blob/develop/plonk-intro-zh/5-plonk-polycom.md)
> - Polynomial Commitments: https://cacr.uwaterloo.ca/techreports/2010/cacr2010-10.pdf

多项式 $f(x) = a_0 + a_1 \cdot x + a_2 \cdot x^2 + \cdots + a_{n-1} \cdot x^{n-1}$ 可以用系数向量表示为 $(a_0, a_1, \cdots, a_{n-1})$。
再将向量套上 Pedersen 承诺的椭圆曲线点：$C_{f(x)} = a_0 \cdot G_0 + a_1 \cdot G_1 + \cdots + a_{n-1} \cdot G_{n-1} + salt \cdot P$

根据 Schwatz-Zippel 引理，攻击者作弊成功的概率可忽略。所以打开一个点，极大概率可以确定证明方的多项式承诺是正确的。

多项式承诺的这个「携带证明的求值」特性非常有用，是一种轻量的 verifiable computation。

步骤：
1. 承诺：选择原象 $x$，计算出 $y = f(x)$，并公开 $y$
2. ~~打开承诺：输出多项式的系数~~
3. ~~校验打开承诺：校验多项式的系数（重新算，系数太多所以成本太高）~~
4. 打开随机点：多点打开或者随机打开 $X = \zeta$
5. 校验随机点：校验多点打开或者随机打开的打开值 $y = f(\zeta)$ 和证明 $\pi$


## 多项式约束系统 （算术化）

算术电路约束系统是基于电路求解困难问题。
多项式约束系统是基于 QAP 求解困难问题 [[零知识证明 ZKP#QAP / QSP]]

QAP约束系统的基本思想是将计算电路表示为一组多项式约束,计算的每一步都对应一组多项式。验证者只需检查一组多项式identities是否成立,就可以在不实际执行计算的情况下验证计算结果的正确性。**这种约束系统可以很好地与各种同态加密和零知识证明方案相结合。**

QAP 作为约束系统的优点:
1. 通用性:QAP可以表达任意算术电路,具有很强的表达能力。
2. 简洁性:使用QAP产生的证明通常比其他一些证明系统更加简短。
3. 可扩展性:QAP证明的验证时间随电路大小呈线性增长,适合大规模计算。


> [!note]
> R1CS 转化为 QAP 的本质是什么？ by Claude-3-opus
>> R1CS转换为QAP的本质是将一组线性约束转化为一组多项式约束。这个转换过程利用了多项式在特定点的取值与约束变量之间的对应关系,从而将电路的计算完整性问题还原为多项式相等性问题。
>> 
>> 具体来说,R1CS到QAP的转换主要涉及以下几个方面:
>> 
>> 1. 变量多项式的构建:对于电路中的每个变量(输入、输出和中间变量),构建一个对应的多项式。这些多项式在每个约束对应的点处取值为相应变量的值,在其他点处为0。
>> 2. 约束多项式的构建:对于每个R1CS约束(a * b = c),构建三个多项式A(x)、B(x)、C(x),分别对应约束的三个部分。多项式在每个约束对应的点处的取值与约束变量的线性组合相等。
>> 3. 目标多项式的构建:引入目标多项式Z(x),使得对于每个R1CS约束,A(x) * B(x) - C(x) = Z(x)在约束对应的点处成立。
>> 4. 验证多项式的构建:引入验证多项式H(x),用于将所有约束多项式的乘积与目标多项式Z(x)相关联。验证多项式与CRS(Common Reference String)结合,用于生成和验证零知识证明。
>> 
>> 通过以上步骤,R1CS约束被转化为一组多项式约束。证明者需要构造一组满足所有约束的多项式,并利用CRS生成证明。验证者只需检查验证多项式在特定点处的取值是否为0,即可在不执行实际计算的情况下确认计算结果的正确性。
>> 
>> 从本质上看,R1CS到QAP的转换建立了电路变量与多项式之间的联系,将电路的计算问题转化为多项式的代数问题。这种转换使得零知识证明协议能够以更高效、更简洁的方式来验证电路的计算完整性,为实现可扩展、可验证的计算提供了重要的理论基础。

## 多项式编码

「多项式编码」在这里指的是将 「R1CS 或 Plonkish 约束等」转为「多项式约束」的过程。
为了能应用 Schwartz-Zipple 引理，很多计算形式都会变为多项式约束形式，所以「多项式编码」是通用过程。

概括地说，构造目标多项式 $f(x), \forall x \in \mathbb{F}$，使得只有正确执行 $f(x)$，才能在随机点 $\omega$ 处得到 $f(\omega) = 0$ 值。这也就证明了证明者确实知道 $f(x)$ 的真实多项式系数。

接下来，我们以一个通用的问题做讲解，
证明
$$
\quad \vec{a} \cdot \vec{b} \overset{?}{=} \vec{c}, \quad  \quad \vec{a} = [a_0, a_1, \cdots, a_{n-1}], \cdots
$$

### 一、构造拉格朗日多项式

利用 Lagrange Basis，构造向量对应的多项式，以及对应的多项式约束
$$
\begin{aligned}
set \quad \mathbb{H} &= \set{\omega_0, \omega_1, \cdots, \omega_{n-1}} \\
a(\omega_0) &= a_0 \\
a(\omega_1) &= a_1 \\
\vdots \\
a(\omega_{n-1}) &= a_{n-1}
\end{aligned}
$$
引入选择多项式 $L_i(X)$：
$$
\begin{equation}
L_i(X) = 
\begin{cases} 
  1 & \text{if } X = \omega_i, \\
  0 & \text{if } X \neq \omega_i.
\end{cases}
\end{equation}
$$
则 $a(X), b(X), c(X)$ 可以按如下方式编码：
$$
\begin{aligned}
a(X) &= L_0(X) \cdot a_0 + L_1(X) \cdot a_1 + L_2(X) \cdot a_2 + \cdots +  L_{n-1}(X) \cdot a_{n-1} \\
b(X) &= L_0(X) \cdot b_0 + L_1(X) \cdot b_1 + L_2(X) \cdot b_2 + \cdots +  L_{n-1}(X) \cdot b_{n-1} \\
c(X) &= L_0(X) \cdot c_0 + L_1(X) \cdot c_1 + L_2(X) \cdot c_2 + \cdots +  L_{n-1}(X) \cdot c_{n-1}
\end{aligned}
$$

如果 $a_i\cdot b_i = c_i$ 成立，那么 $a(w_i)\cdot b(w_i) = c(w_i)$。如果 $\vec{a}\circ\vec{b}{=}\vec{c}$ ，那么 
$$
a(X)\cdot b(X) = c(X),\quad \forall X\in H
$$

我们现在已经把两个向量的按位乘积问题转换到了三个多项式之间的关系，接下来的问题是如何进行随机挑战验证。

我们发现：如果直接让 Verifier 发送随机数 $\zeta$ 挑战上面的等式，那么 $\zeta$ 只能属于 $H$。如果只存在一个 $j$ 使得 $a_j\cdot b_j\neq c_j$，那么 Verifier 的一次挑战能发现这个错误的概率只有 $\frac{1}{|n|}$，这样 Verifier 需要挑战多次才能缩小检测出错的概率。不过这样不满足我们的要求，我们希望只通过一次挑战来检测出 Prover 的作弊行为。

### 二、扩大 $X$ 的定义域

我们可以把上面的等式的 $X$ 取值范围去除，换成下面的等式：
$$
a(X)\cdot b(X) - c(X) = q(X)\cdot z_H(X), \quad\forall X\in \mathbb{F}
$$
如果我们让 Prover 计算出这个 $q(X)$，并且发送给 Verifier，又因为 $H$ 是已知的系统参数，Verifier 可以自行计算 $z_H(X)$，那么 Verifier 只需要一次随机检测即可判断 $a(X)\cdot b(X)-c(X)$ 是否在 $H$ 处等零。

$$
a(\zeta)\cdot b(\zeta)-c(\zeta) \overset{?}{=} q(\zeta)\cdot z_H(\zeta)
$$
## 多项式数学基础

- [WIKI 多项式](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A0%85%E5%BC%8F)
- [多项式除法 | 宋浩老师](https://www.bilibili.com/video/BV1gt4y1g7GA)

线性多项式：一次多项式又称为**线性多项式** 或 [单项式](https://zh.wikipedia.org/wiki/%E5%8D%95%E9%A1%B9%E5%BC%8F "单项式")

**多项式除法**:

$z(X) = (X - a_0)(X - a_1)..(X..a_n)$
$f(X) = z(X) * q(X)$

$z(X)$ 称为 $f(X)$ 的零多项式 Vanishing Polynomial，$q(X)$ 称为商多项式 Quotient Polynomial。这个例子因为能整除，所以没有余数，余数是叫 Reminder Polynomial，不过我想如果有 Vanishing Polynomial 就不会存在 Reminder 吧。

### 多项式余数定理（多项式除法定理或余数定理）

> [!seealso] 
> - https://zh.wikipedia.org/wiki/%E9%A4%98%E5%BC%8F%E5%AE%9A%E7%90%86

**多项式余式定理**（英语：Polynomial remainder theorem）是指一个多项式 $f(x)$ 除以一线性多项式 $x-a$ 的余数是 $f(a)$

### 单位根 Roots of Unity

- https://github.com/sec-bit/learning-zkp/blob/develop/plonk-intro-zh/2-plonk-lagrange-basis.md#%E5%8D%95%E4%BD%8D%E6%A0%B9-roots-of-unity
- [高等代数020 - n次单位根_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TE41147KA/?spm_id_from=333.880.my_history.page.click&vd_source=b7d8f4fe7d99d7045075d9b1f350612b)
- [单位根_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1iQ4y1Q7M1/?spm_id_from=333.880.my_history.page.click&vd_source=b7d8f4fe7d99d7045075d9b1f350612b)

有点复杂，还牵涉到三角函数了，跳过

### 拉格朗日插值法 Lagrange Interpolation

> [!seealso] 
> - ⭐️⭐️⭐️ [找通项的终极方法！让每个人都能听懂的【拉格朗日插值法】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ZC4y1p77B/?spm_id_from=333.880.my_history.page.click&vd_source=b7d8f4fe7d99d7045075d9b1f350612b)
> - ⭐️⭐️⭐️ [【拉格朗日插值法的本质】拉格朗日，孙子，与每个人都能推出来的插值法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TR4y1j745/?spm_id_from=333.880.my_history.page.click&vd_source=b7d8f4fe7d99d7045075d9b1f350612b)

**Lagrange Basis**:
$$
\begin{aligned}
L_i(x) &= \prod_{\substack{j \in \mathbb{H} \backslash i}}{\frac{x - x_j}{x_i - x_j}}
\\
f(x) &= \sum{y_i \cdot L_i(x)} \\
     &= y_0 \cdot L_0(x) + y_1 \cdot L_1(x) + y_2 \cdot L_2(x) + \cdots + y_{n-1} \cdot L_{n-1}(x)
\end{aligned}
$$

**基于拉格朗日插值，灵活地表达和合并多个多项式约束：**
比如我们想约束 $\vec{a}=(h,a_1,a_2,\ldots,a_{N-1})$ 向量的第一个元素为 $h$。那么我们可以对这个向量进行编码，得到 $a(X)$，并且进行如下约束：

$$
L_0(X)(a(X)-h) = 0, \quad \forall X\in H
$$

Verifier 可以挑战验证下面的多项式等式：

$$
L_0(X)(a(X)-h) = q(X)\cdot z_H(X)
$$

再比如，我们想约束 $\vec{a}=(h_1,a_1,a_2,\ldots,a_{N-2},h_2)$ 向量的第一个元素为 $h_1$，最后一个元素为 $h_2$，其它元素任意。那么 $a(X)$ 应该满足下面两个约束。

$$
\begin{split}
L_0(X)\cdot (a(X)-h_1) &= 0, \quad \forall X\in H\\
L_{N-1}(X)\cdot(a(X)-h_2) &= 0, \quad \forall X\in H
\end{split}
$$

那么通过 Verifier 给一个随机挑战数（ $\alpha$），上面两个约束可以合并为一个多项式约束：

$$
L_0(X)\cdot (a(X)-h_1) + \alpha\cdot L_{n-1}(X)\cdot(a(X)-h_2) = 0, \quad \forall X\in H
$$

接下来，Verifier 只要挑战下面的多项式等式即可：

$$
L_0(X)\cdot (a(X)-h_1) + \alpha\cdot L_{n-1}(X)\cdot(a(X)-h_2) = q(X)\cdot z_H(X)
$$

如果想验证 $\vec{a}$ 和 $\vec{b}$ 两个等长向量除第一个元素之外，其它元素都相等，那要如何约束呢？假设 $a(X)$ 和 $b(X)$ 为两个向量的多项式编码，那么它们应该满足：

$$
(X-\omega^0)(a(X)-b(X))=0
$$

当 $X=\omega^0$ 时，左边多项式的第一个因子等于零，而 $X\in H\backslash\\{\omega^0\\}$ 时，则左边第二因子等于零，即表达了除第一项可以不等之外，其它点取值都必须相等。

可以看出，采用 Lagrange 多项式，我们可以灵活地约束多个向量之间的关系，并且可以把多个约束合并在一起，让 Verifier 仅通过很少的随机挑战就可验证多个向量约束。

## 多项式求解困难问题 QAP

> [!seealso] 
> - [零知识证明 - 从QSP到QAP |  微信公众号 | Star Li 星想法](https://mp.weixin.qq.com/s/eU8mp81VhpV-g1x89-uZYA)
> - [[Quadratic Span Programs and Succinct NIZKs without PCPs.pdf]]
> - https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649
> - [Quadratic Arithmetic Programs | RareSkills](https://www.rareskills.io/post/quadratic-arithmetic-program)
> - [Explaining SNARKs Part V: From Computations to Polynomials | electriccoin](https://electriccoin.co/blog/snark-explain5/) 看不懂，写得太粗了
> -  [[零知识证明 ZKP#密码学前置知识：重要的 NP 问题]]
> - [[QAP.pdf]]

**SP**:
Span 即线性空间里的张成，其实就是向量的所有线性组合构成的空间。借助 Span 的定义，我们还可以定义线性相关和线性无关；
Program 意为“计算模型”；
Span Program 的全称是 Linear Span Program，表示「以线性组合的张量为核心的计算模型」。

**QSP/QAP**:
Linear Span Program 只能表示向量的「线性组合」$c\vec{v} + d\vec{w}$，不能表示「非线性组合」$\vec{v} \cdot \vec{w}$，好像说能在多项式时间内求解；
Quadratic Span Program 拓展了 Linear Span Program，使其能表示「二次组合」 $\vec{v} \cdot \vec{w}$，好像说是 NP 求解问题。

如此一来，我们就能用 QSP 来表达 R1CS 了。可以理解 QAP 和 QSP 是差不多一个东西。

**Selector Polynomial**:
[深入浅出零知识证明｜华东师范大学博士生 | Hacker Dōjō](https://www.bilibili.com/video/BV1EN4y1R7Z8/?share_source=copy_web&vd_source=f5dc677a08b683e2fe0b10f9405bbd46&t=1440)
[[QAP.pdf]]

$$
\begin{aligned}
p(x) &= L(x) \cdot R(x) - O(x) \\

     &= (\sum_{i=1}^{9}{c_i \cdot l_i(x)}) \times (\sum_{i=1}^9{c_i \cdot r_i(x)}) - (\sum_{i=1}^9{c_i \cdot o_i(x)}) = 0 \\
     
p(x) &= V(x) \cdot q(x)
\end{aligned}
$$
$c_i(x)$ is selector polynomial, $V(x)$ is vanishing polynomial,

⭐️⭐️⭐️ **QAP 求解困难问题**：对于 $f(x) = z(x) \cdot q(x)$，，其中 $z(x)$ 是 Vanishing Polynomial。已知 $f(x)$，求 $z(x)$。
本质上，就是求多项式 $f(x)$ 的整除式，所以又叫多项式因式分解问题、多项式整除问题、多项式求解整除问题 [[零知识证明 ZKP#密码学前置知识：重要的 NP 问题]]

在我的理解里，也可以基于 QAP 求解困难问题来理解 Schwatz-Zipple 引理：已知目标多项式 $f(x), \forall x \in \mathbb{F}$，只能暴力求解 $z(x)$。在这种情况下，只有确实掌握了 $z(x)$ ，才能在随机点 $\omega$ 处得到 $f(\omega) = 0$ 值。

❓❓❓感觉还是串不起来❓❓❓

## zk-SNARK 协议

> [!seealso] 
> - https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell
> - [Simplifying the moon math behind SNARKs](https://www.youtube.com/watch?v=1UNGj3X2xw8&ab_channel=ThePhoenixGuild)
> - https://tlu.tarilabs.com/cryptography/zk-snarks  tarilabs的文章质量不错
> - [[零知识证明学习资源汇总#「荐文十三」V 神的 zk-SNARKs 科普文章]]
> - [The Mathematics behind zkSNARKS](https://www.youtube.com/watch?v=iRQw2RpQAVc&list=PLbU_qfxXpyN_T3lkWGfZGOMWZC2rnYdFt&index=3&ab_channel=LeastAuthority)
> - [Math building blocks](https://zkiap.com/#:~:text=%E2%80%A3-,Session,-3%20(Friday%201) and [pdf](https://assets.super.so/9c1ce0ba-bad4-4680-8c65-3a46532bf44a/files/b42768d1-4e53-40be-8208-671508dd3cc8.pdf)
> - [[零知识证明学习资源汇总#「荐文十五」[Why and How zk-SNARK Works](https //arxiv.org/pdf/1906.07221.pdf)]]
> - [星辰实验室 P1: 零知识证明 与 zk-SNARK ( 数学版 ）](https://youtu.be/TQjzKAkHFls?t=831)
> - [Circom](https://docs.circom.io/)
> - https://zkiap.com/
> - [[零知识证明PPT-星辰实验室.pdf]]
> - [[零知识证明技术文档-星辰实验室.pdf]]

![[零知识证明PPT-星辰实验室.pdf#page=10&selection=0,0,1,2|零知识证明PPT-星辰实验室, page 10]]



![[Pasted image 20240527150402.png|300x200]]

## 历史

论文的命名规则：作者的首字母组合 - 发表年份。e.g. Groth16 的作者是 Groth，发表年份为 2016 年。

GMR85 提出**零知识证明**和**交互式证明**的概念。
GMW91 证明了任何一个 NP 问题都有对应的零知识证明算法。
Sigma 协议涉及思路。对于一些特定问题，如离散对数问题，可以使用 Sigma 协议来简单高效地证明。
zk-SNARKs 于 2013 年提出，具有普适性。第一代 zk-SNARKs 以 PGHR13 为代表，第二代以 Groth16 为代表。
Universal zk-SNARKs 和 Transparent zk-SNARKs 于 2018 年提出，Sonic 算法是第一个 Universal zk-SNARKs 算法。

https://www.di.ens.fr/~nitulesc/publications.html
![[Pasted image 20240604162144.png | 500 x 200]]

## zk-Rollup

数据：
1. 提交到一层的状态数据，公开的，$statement = (1, MerkleRoot, PubData)$
2. 二层的数据，秘密的，$witness = (s_1, ..., s_n)$
3. 构造向量 $s = (statement, witness) = (1, MerkleRoot, PubData; s_1, ..., s_n)$

等价映射：Merkle tree/Hash/EDSA/... $\rightarrow$ R1CS $\rightarrow$ ...

## 不懂的概念

- Fiat-Shamir heuristic
- [[零知识证明 ZKP#多项式承诺]]，承诺什么？打开什么？校验什么？串不起来。

## 常见名词

- Commit-and-Prove
- Common Reference String (CRS)
- Probabilistically Checkable Proofs (PCPs)
- **Secp256k1** is an elliptic curve used primarily in the context of cryptographic algorithms and is most famously associated with Bitcoin and other cryptocurrencies.
  The name secp256k1 is derived from the curve's properties: "sec" stands for "Standards for Efficient Cryptography," "p" represents the prime field, "256" signifies the bit length of the prime field, and "k1" indicates that it is the first curve of its kind recommended by SECG.

## END

---
问题：



![[Pasted image 20240608015336.png]]



![[Pasted image 20240608020723.png]]


![[Pasted image 20240608022843.png]]


---

但上面这个等式不足以约束重排向量的可靠性。考虑如果 $\vec{f}'=(9,9,9,9,9,9,9,9)$ ，也会满足上面的等式，但是 $\vec{f}'$ 并不是合法的查询记录。因此，我们还要加入一条约束防止出现 $\vec{f}'$ 在 $H$ 上 循环回卷导致的漏洞：要求 $\vec{f}'$ 和 $\vec{t}'$ 两个向量的第一个元素必须相同， 即 $f'_0=t'_0$，用多项式约束表达如下：

$$
L_0(X)\cdot(f'(X)-t'(X)) = 0, \quad \forall x\in H
$$




> 生产级别下，lookup table 的大小
> 生产下，lookup 的常用场景
> 在 setup 时必须要把完整的 lookup table 公开出来吗？

> 第二步使用了两个随机数 $\gamma_1, \gamma_2$ 来折叠多项式，
> 第四步使用了一个随机数来折叠多项式，然后是在折叠的过程中用 $\alpha, \alpha^2, \alpha^3$ 来折叠不同的多项式，
> 我的疑问是说，第二步的时候能否也使用 $\gamma_1, \gamma_2$ 的方式来折叠多个多项式？
> 
> gamma 是随机选点，
> alpha 是做折叠
